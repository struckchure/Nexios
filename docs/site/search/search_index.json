{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Nexios Framework <p>High-performance, easy to learn, and built for modern web applications.</p>      Get Started"},{"location":"#why-choose-nexios","title":"Why Choose Nexios?","text":"\ud83d\ude80 High Performance <p>Optimized for speed and efficiency, handling thousands of requests per second.</p> \ud83d\udee0\ufe0f Easy to Use <p>Minimal setup, clear syntax, and developer-friendly documentation.</p> \ud83c\udf0d Scalable <p>Designed to grow with your application, from small projects to enterprise solutions.</p>"},{"location":"#nexios-vs-other-frameworks","title":"Nexios vs Other Frameworks","text":"Feature Nexios \ud83d\ude80 FastAPI \u26a1 Django \ud83c\udfd7 Flask \ud83c\udf76 Speed \u26a1\u26a1\u26a1\u26a1\u26a1 \u26a1\u26a1\u26a1\u26a1 \u26a1\u26a1 \u26a1\u26a1\u26a1 Ease of Use \u2705\u2705\u2705\u2705\u2705 \u2705\u2705\u2705\u2705 \u2705\u2705\u2705 \u2705\u2705\u2705\u2705 ORM Support Any! SQLAlchemy Django ORM SQLAlchemy Async Support \u2705 \u2705 \u274c (Django 4.1+ has partial) \u274c Authentication \u2705 \u2705 \u2705 \u274c Built-in Admin Panel Coming Soon \u274c \u2705 \u274c Best For APIs &amp; Full Apps APIs Full-stack Web Apps Small Apps"},{"location":"#stay-connected","title":"Stay Connected","text":""},{"location":"#create-and-activate-a-virtual-environment-then-install-nexios","title":"Create and activate a virtual environment, then install Nexios.","text":"<ol> <li>Create and Activate a Virtual Environment</li> </ol> <p>Before installing Nexios, it's recommended to use a virtual environment to keep dependencies isolated.</p>"},{"location":"#on-windows-cmd-or-powershell","title":"On Windows (CMD or PowerShell):","text":"<pre><code>python -m venv venv\nvenv\\Scripts\\activate\n</code></pre>"},{"location":"#on-macoslinux-terminal","title":"On macOS/Linux (Terminal):","text":"<pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre> <ol> <li>Install Nexios</li> </ol> <p>Once the virtual environment is active, install Nexios using pip: <pre><code>pip install nexios-api\n</code></pre></p> <ol> <li>Verify Installation</li> </ol> <p>Check if Nexios is installed correctly by running: <pre><code>nexios\n</code></pre> if nexios is installed the current version will be displayed</p>"},{"location":"application/","title":"Nexios ASGI Backend Framework: Application Entry Point","text":"<p>Nexios is a modern, high-performance ASGI (Asynchronous Server Gateway Interface) backend framework designed for building scalable and efficient web applications and APIs. It provides a lightweight, flexible, and extensible foundation for developing asynchronous web services. This document provides a comprehensive guide to the application entry point in Nexios, explaining how to set up, configure, and run a Nexios application.</p>"},{"location":"application/#introduction-to-the-nexios-application-entry-point","title":"Introduction to the Nexios Application Entry Point","text":"<p>The application entry point is the core of any Nexios application. It serves as the central hub where all incoming requests are processed, routed to the appropriate handlers, and responses are returned. The entry point is typically defined in your main application file (e.g., <code>main.py</code>) and is responsible for initializing the application, defining routes, adding middleware, and managing application lifecycle events.</p> <p>The Nexios framework is built with simplicity and performance in mind, making it an excellent choice for developers who want to build modern web applications without the overhead of more complex frameworks.</p>"},{"location":"application/#key-features-of-the-nexios-application-entry-point","title":"Key Features of the Nexios Application Entry Point","text":"<ol> <li>ASGI Compatibility: Nexios is fully compliant with the ASGI specification, ensuring compatibility with ASGI servers like Uvicorn, Hypercorn, and Daphne.</li> <li>Routing: Easily define routes and attach them to the application.</li> <li>Middleware Support: Add middleware to process requests and responses globally.</li> <li>Lifespan Events: Handle application startup and shutdown events for resource management.</li> <li>Extensibility: Customize and extend the application with additional functionality as needed.</li> <li>Asynchronous by Design: Built to handle asynchronous operations, making it ideal for high-performance applications.</li> </ol>"},{"location":"application/#creating-the-application-entry-point","title":"Creating the Application Entry Point","text":"<p>Create a new Python file (e.g., <code>main.py</code>) and define your Nexios application. Here\u2019s an example: or use the nexios cli tool</p> <pre><code>from nexios import NexioApp #or get_application\nfrom nexios.routing import Route\n\n# Define a route handler for the home page\nasync def home(req, res):\n    return res.json({\"message\": \"Welcome to Nexios!\"})\n\n# Define a route handler for the about page\nasync def about(req, res):\n    return res.josn({\"message\": \"About Nexios\"})\n\n# Create the Nexios application\napp = NexioApp() #or get_application\n\n# Add routes to the application\napp.add_route(Route(\"/\", home, methods=[\"GET\"]))\napp.add_route(Route(\"/about\", about, methods=[\"GET\"]))\n\n# Optional: Add middleware\n# app.add_middleware(...)\n\n# Optional: Add lifespan event handlers\n@app.on_startup()\nasync def startup():\n    print(\"Application is starting up...\")\n\n@app.on_evon_shutdownent()\nasync def shutdown():\n    print(\"Application is shutting down...\")\n</code></pre>"},{"location":"application/#run-the-application","title":"Run the Application","text":"<p>To run the Nexios application, you need an ASGI server like Uvicorn. Follow these steps:</p> <ol> <li> <p>Install Uvicorn:    <pre><code>pip install uvicorn\n</code></pre></p> </li> <li> <p>Run the application using Uvicorn:    <pre><code>uvicorn main:app --reload\n</code></pre></p> </li> <li> <p><code>main:app</code> refers to the <code>app</code> object in the <code>main.py</code> file.</p> </li> <li> <p>The <code>--reload</code> flag enables auto-reloading during development.</p> </li> <li> <p>Access the application in your browser or via an HTTP client:</p> </li> <li><code>http://127.0.0.1:8000/</code> \u2192 Returns <code>{\"message\": \"Welcome to Nexios!\"}</code></li> <li><code>http://127.0.0.1:8000/about</code> \u2192 Returns <code>{\"message\": \"About Nexios\"}</code></li> </ol>"},{"location":"application/#the-nexiosapp-class","title":"The <code>NexiosApp</code> Class","text":"<p>The <code>Nexios</code> class is the core of your application. It is responsible for managing routes, middleware, and lifecycle events. When you instantiate the <code>Nexios</code> class, you create an application object that serves as the entry point for all incoming requests.</p> <p><pre><code>app = Nexios()\n</code></pre> get_application is a function that simplifies application creation. Instead of manually instantiating NexiosApp and configuring it, this function:</p>"},{"location":"application/#defining-route-handlers","title":"Defining Route Handlers","text":"<p>Route handlers are asynchronous functions that process incoming requests and return responses. Each handler takes a <code>request</code> ans a <code>response</code> object as an argument and returns a response. In the example above, the <code>home</code> and <code>about</code> handlers return JSON responses.</p> <pre><code>async def home(request, response):\n    return response.json({\"message\": \"Welcome to Nexios!\"})\n</code></pre>"},{"location":"application/#adding-routes","title":"Adding Routes","text":"<p>Routes are added to the application using the <code>add_route</code> method. This method take <code>Routes</code> as a parameter which takes the following parameters: - <code>path</code>: The URL path for the route. - <code>handler</code>: The function that handles the request. - <code>methods</code>: A list of HTTP methods supported by the route (e.g., <code>[\"GET\"]</code>).</p> <pre><code>app.add_route(Routes(\"/\", home, methods=[\"GET\"]))\n</code></pre>"},{"location":"application/#middleware","title":"Middleware","text":"<p>Middleware allows you to process requests and responses globally. You can add middleware to the application using the <code>add_middleware</code> method. Middleware is useful for tasks like authentication, logging, and request/response modification.</p> <pre><code># Example of adding middleware\n# app.add_middleware(SomeMiddlewareClass)\n</code></pre>"},{"location":"application/#lifespan-events","title":"Lifespan Events","text":"<p>Lifespan events allow you to execute code during the application's startup and shutdown phases. These events are useful for tasks like initializing database connections, loading configuration, or cleaning up resources.</p> <pre><code>@app.on_startup()\nasync def startup():\n    print(\"Application is starting up...\")\n\n@app.on_shutdown(\"shutdown\")\nasync def shutdown():\n    print(\"Application is shutting down...\")\n</code></pre>"},{"location":"application/#advanced-configuration","title":"Advanced Configuration","text":"<p>Customizing the Application</p> <p>The <code>Nexios</code> ionstance class provides several options for customizing your application. For example, you can configure the application to use custom exception handlers, enable debugging, or set default headers.</p> <pre><code>from nexios.config import MakeConfig\n\nconfig = MakeConfig({\n    \"debug\" : True\n})\napp = Nexios(config=config)\n</code></pre>"},{"location":"application/#best-practices-for-using-the-application-entry-point","title":"Best Practices for Using the Application Entry Point","text":"<ol> <li>Organize Routes: Group related routes together and consider usingm Router for better modularity.</li> <li>Use Middleware Wisely: Middleware can add overhead to your application, so use it only when necessary.</li> <li>Handle Lifespan Events: Use startup and shutdown events to manage resources efficiently.</li> <li>Enable Debugging in Development: Set <code>debug=True</code> during development to get detailed error messages.</li> <li>Test Your Application: Use tools like <code>pytest</code> to write tests for your application.</li> </ol>"},{"location":"author/","title":"Author","text":"<p>Here's a sleek Markdown file to advertise you as the author of the Nexio Framework. It includes sections about you, the framework, and its features, with placeholders for images that can be replaced with real ones later.</p> <pre><code># Introducing **Nexio Framework** \ud83d\ude80  \n### By [Dunamis](https://github.com/TechWithDunamix)  \n\n![Nexio Banner](https://via.placeholder.com/1200x400?text=Nexio+Framework)  \n\n---\n\n## \ud83d\udc4b About Me  \n\nHi, I'm **Dunamis**, a passionate developer from Nigeria specializing in **Python**, **Django**, **React**, and more. With years of experience, I strive to build innovative tools and frameworks that empower developers to create impactful applications effortlessly.  \n\n---\n\n## \ud83c\udf1f About Nexio  \n\n**Nexio** is a modern, lightweight Python web framework designed for building high-performance, scalable web applications with simplicity and elegance. Nexio redefines how developers approach rapid application development by blending robust features with intuitive design.\n\n---\n\n## \u2728 Why Choose Nexio?  \n\n- **\ud83d\ude80 Blazing Fast**: Powered by cutting-edge asynchronous capabilities.  \n- **\ud83d\udee0\ufe0f Easy to Use**: Write less boilerplate, focus on your application logic.  \n- **\ud83d\udd12 Secure**: Built with best practices to ensure safe and reliable applications.  \n- **\ud83c\udfaf Scalable**: Ideal for projects of any size, from MVPs to enterprise-grade systems.  \n- **\ud83d\udce6 All-in-One**: Includes routing, ORM, middleware, and more out of the box.\n\n---\n\n## \ud83d\udcda Key Features  \n\n- **Flexible Routing System** for clean and organized code.  \n- **Built-in Database ORM** for effortless data modeling.  \n- **Asynchronous by Design** for real-time apps.  \n- **Easy Deployment** with Uvicorn, Docker, and CI/CD integrations.  \n- **Rich Plugin Ecosystem** to extend its functionality.  \n\n![Features Illustration](https://via.placeholder.com/800x300?text=Features+of+Nexio)  \n\n---\n\n## \ud83d\ude80 Get Started  \n\nInstall Nexio with pip:  \n\n```bash\npip install nexio\n</code></pre> <p>Create a new project in seconds:  </p> <pre><code>nexio create my_project\ncd my_project\nuvicorn main:app --reload\n</code></pre> <p>Your app is live at http://localhost:8000!  </p>"},{"location":"author/#resources","title":"\ud83d\udd17 Resources","text":"<ul> <li>\ud83d\udcd6 Documentation </li> <li>\ud83e\uddd1\u200d\ud83d\udcbb GitHub Repository </li> <li>\ud83d\udee0\ufe0f Contribute </li> </ul>"},{"location":"author/#join-the-community","title":"\ud83e\udd1d Join the Community","text":"<p>Stay updated and get involved:  </p> <ul> <li>\ud83c\udf10 Follow me on Twitter </li> <li>\ud83d\udcac Join our Slack or Discord </li> </ul> <p> </p>"},{"location":"author/#why-i-built-nexio","title":"\ud83d\udca1 Why I Built Nexio","text":"<p>As a developer, I often struggled with frameworks that were either too rigid or overly complex for small-to-medium projects. Nexio was born out of a desire to simplify the development process while providing enough power to tackle real-world challenges.  </p> <p>With Nexio, I hope to inspire other developers to dream bigger, code smarter, and build faster.  </p>"},{"location":"author/#lets-build-together","title":"\ud83c\udf1f Let's Build Together!","text":"<p>If you\u2019re excited about Nexio, give it a \u2b50 on GitHub!  </p> <p>Let\u2019s create something amazing, one line of code at a time. ```</p>"},{"location":"author/#tips-to-enhance-this-markdown","title":"Tips to Enhance This Markdown:","text":"<ol> <li>Replace Image Placeholders: Update <code>https://via.placeholder.com/...</code> with actual banner and illustration links.</li> <li>Add Live Links: Replace example links for documentation, Slack, and Discord with real ones.</li> <li>Use Custom Branding: Incorporate logos or graphics that align with Nexio's identity.</li> </ol> <p>Let me know if you need graphics or help polishing the presentation further!</p>"},{"location":"basic_routing/","title":"Basic Routing","text":""},{"location":"basic_routing/#basic-routing","title":"Basic routing","text":""},{"location":"basic_routing/#what-is-a-route","title":"What is a Route?","text":"<p>A route is like a map that tells your app what to do when someone visits a specific web address (like /users or /products). It listens for certain HTTP methods (like GET, POST) and then runs specific code (called handlers) to respond to the request.</p> <p>Routing is basically figuring out how your app responds when a client hits a specific endpoint, which is a URI (or path) paired with an HTTP method (like GET, POST, etc.).</p> <p>Each route can have one or more functions that handle the request, and these functions run when the route gets matched.</p> <p>Nexios provide many style for routing includid decorators,router etc.</p> <p>Below is a basic routing with decorators :</p> <pre><code>@app.route(\"/api/endpoint\",methods = ['get'])\nasync def endpoint_handler(request, response):\n\n    return response.send(\"Hello world\")\n</code></pre> <p>Explanation</p> <ul> <li>app : This refer to the app instance seen in the Hello world example</li> <li> <p>.route : This is a method provided by the app instance as a decorator</p> </li> <li> <p>/api/endpoint : This is the route that is refers to the route e.g www.domain.com/endpoint</p> </li> <li> <p>methods : define how a client interacts with a server. Common methods include GET (retrieve), POST (create), PUT (update), DELETE (remove), and PATCH (partially update).</p> </li> <li> <p>Handler Function(endpoint_handler): This is the async function that gets triggered when the route is matched. It handles the incoming request and decides what to send back as a response.</p> </li> </ul> <p>For more details about routing, see the routing guide.</p>"},{"location":"hello_world/","title":"Simple Hello world example","text":"<p>Here's the simplest Nexios app you can make\u2014it's just one file. This is different from what you'd get with the Nexios CLI tool, which sets up a full app with multiple Python files and folders for different tasks.</p> <pre><code>from nexios import NexioApp\n\napp = NexioApp()\n@app.route(\"/api/endpoint\",methods = ['get'])\nasync def endpoint_handler(request, response):\n\n    response.json({\n        \"text\":\"Welcome to nexios\n    })\n</code></pre>"},{"location":"hello_world/#running-locally","title":"Running Locally","text":"<ol> <li> <p>ensure you have followed the  Installation guide</p> </li> <li> <p>Just like other python asgi frameworks(Fastapi,etc) Nexios uses uvicorn as it the server , you can run it as below</p> </li> </ol> <pre><code>uvicorn main:app --reload\n</code></pre> <ul> <li>The main should be the name of the file the app is located at </li> <li>The app should be the nexioapp instance </li> <li>the reload flag ensure the server listens for changes in your files</li> </ul> <p>Learn more about Uvicorn</p> <p>Request Object: This object contains all the information about the incoming HTTP request, such as headers, body data, query parameters, and more. You can interact with this object to retrieve the data sent by the client.</p> <p>Response Object: This object represents the response that will be sent back to the client. You can use it to send data, set headers, and define the status code of the response.</p> <p>Top to page</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installing","title":"Installing","text":"<p>Assuming Python is already installed on your system, create a directory to hold your application and set it as your working directory.</p> <p>Nexios require Python 3.6 or higher.</p> <pre><code>mkdir your_project_name\ncd  your_project_name\n</code></pre> <p>Use Python's venv module to create a virtual environment. This isolates your project's dependencies, ensuring they don't interfere with system-wide packages or other projects. Run the following command to initialize the virtual environment:</p> <pre><code>python -m venv venv\n</code></pre> <ul> <li> <p>The name venv is conventional, but you can choose any name for your virtual environment folder.</p> </li> <li> <p>This virtual environment will store all the libraries and dependencies your project requires.</p> </li> </ul> <p>Activate the Virtual Environment</p> <p>Depending on your operating system, activate the virtual environment using one of the following commands:</p> <ul> <li>Windows</li> </ul> <pre><code>    venv\\Scripts\\activate\n</code></pre> <ul> <li>Linux/Mac</li> </ul> <pre><code>    source venv/bin/activate\n</code></pre> <p>After activation, your terminal will display the virtual environment's name as a prefix (e.g., (venv)), indicating that it is active.</p> <p>Once activated, you can install project-specific dependencies, and they will be stored within the virtual environment. When you're done working on the project, deactivate the environment with the deactivate command</p> <p>Run the follow command to install nexios</p> <pre><code>pip install nexios\n</code></pre> <p>Confirm the installation by running :</p> <pre><code>python -m nexios\n</code></pre> <p>You should see an output like this :</p> <pre><code>      _   _                 _               \n | \\ | |               (_)              \n |  \\| |   ___  __  __  _    ___    ___ \n | . ` |  / _ \\ \\ \\/ / | |  / _ \\  / __|\n | |\\  | |  __/  &gt;  &lt;  | | | (_) | \\__ \\\n |_| \\_|  \\___| /_/\\_\\ |_|  \\___/  |___/\n\n    \ud83d\ude80 Welcome to Nexios \ud83d\ude80\n      The sleek ASGI Backend Framework\n      Version: X.X.X\n</code></pre> <p>Congrat you have installed nexios</p>"},{"location":"introduction/","title":"Nexios: ASGI Python Web Framework","text":"<p>Nexios is a lightweight and fast ASGI web framework designed for asynchronous web applications. With support for asynchronous routing, template engines, WebSockets, and real-time features, Nexios is optimized for high-performance, real-time, and concurrent applications.</p> <p>Let's dive into the features of Nexios with some practical examples that showcase its power and flexibility.</p>"},{"location":"introduction/#key-features-of-nexios-asgi-framework","title":"Key Features of Nexios (ASGI Framework)","text":""},{"location":"introduction/#1-asynchronous-routing","title":"1. Asynchronous Routing","text":"<p>In Nexios, routes can be defined using asynchronous functions, allowing your application to handle requests efficiently without blocking the main event loop.</p>"},{"location":"introduction/#example","title":"Example:","text":"<p><pre><code>@app.route(\"/api/greet\", methods=[\"GET\"])\nasync def greet_user(req, res):\n    user = await get_user_from_db(req.query[\"username\"])\n    return res.json({\"message\": f\"Hello, {user.username}!\"})\n</code></pre> With Nexios, this simple asynchronous route can handle multiple requests concurrently, making your web application more scalable.</p>"},{"location":"introduction/#2-template-engine-support","title":"2. Template Engine Support\u00b6","text":"<p>Nexios supports a wide variety of templating engines, allowing you to render dynamic content easily in your web application. Whether you're using Mako, Jinja2, or any other templating engine, Nexios provides seamless integration for rendering HTML, emails, or other templated content.</p>"},{"location":"introduction/#example_1","title":"Example","text":"<pre><code>from jinja2 import Environment, FileSystemLoader\nfrom pathlib import Path\nfrom nexios import Nexios\n\napp = Nexios()\n\ntemplate_env = Environment(loader=FileSystemLoader(str(Path(__file__).parent / \"templates\")))\n\n@app.route(\"/profile/{user_id}\")\nasync def user_profile(req, res):\n    user = await get_user_from_db(req.path_params[\"user_id\"])\n\n    template = template_env.get_template(\"profile.html\")\n\n    rendered_html = template.render(user=user)\n\n    return res.html(rendered_html)\n</code></pre> <p>Nexios provides flexible support for any templating engine, allowing you to render dynamic content asynchronously, ensuring that template rendering does not block other requests and keeps your application fast and responsive.</p>"},{"location":"introduction/#advantages","title":"Advantages:","text":"<ul> <li>Flexibility: Use any templating engine you prefer for your project.</li> <li>Asynchronous Rendering: Render templates asynchronously to handle more requests concurrently.</li> <li>Seamless Integration: Easily integrate the template engine into your Nexios routes for dynamic HTML generation.</li> </ul> <p>By supporting various templating engines, Nexios makes it easy to generate dynamic content while keeping your web applications scalable and efficient.</p>"},{"location":"introduction/#3-asynchronous-utilities","title":"3. Asynchronous Utilities","text":"<p>For real-time web apps, handling I/O-bound tasks asynchronously is a game changer. Nexios provides utilities to handle file uploads, cookies, headers, and more asynchronously.</p>"},{"location":"introduction/#example_2","title":"Example:","text":"<p><pre><code>@app.route(\"/upload\", methods=[\"POST\"])\nasync def upload_file(req, res):\n    uploaded_file = await req.files.get(\"file\")\n    await save_file(uploaded_file)\n    return res.json({\"message\": \"File uploaded successfully!\"})\n</code></pre> The upload is processed without blocking other requests, ensuring smooth user experience even during heavy I/O operations.</p>"},{"location":"introduction/#4-built-in-asgi-server","title":"4. Built-In ASGI Server","text":"<p>Nexios runs on ASGI-compatible servers like Uvicorn and Daphne, allowing it to handle thousands of concurrent connections efficiently.</p>"},{"location":"introduction/#example_3","title":"Example:","text":"<p><pre><code>uvicorn main:app --host 0.0.0.0 --port 8000 --reload\n</code></pre> This setup ensures Nexios runs efficiently and scales effortlessly for applications that require high concurrency.</p>"},{"location":"introduction/#5-scalability-and-performance","title":"5. Scalability and Performance","text":"<p>Since Nexios is asynchronous by nature, it can process multiple requests simultaneously without blocking, making it ideal for real-time applications such as:</p> <ul> <li>Chat applications</li> <li>Real-time dashboards</li> <li>Online games</li> </ul>"},{"location":"introduction/#example_4","title":"Example:","text":"<p><pre><code>@app.route(\"/notifications\", methods=[\"GET\"])\nasync def notifications(req, res):\n    # Simulate long-running task (e.g., fetching notifications)\n    notifications = await fetch_notifications(req.query[\"user_id\"])\n    return res.json({\"notifications\": notifications})\n</code></pre> Even while waiting for data, Nexios can handle other incoming requests, making it a perfect fit for highly concurrent applications.</p>"},{"location":"introduction/#6-websocket-support","title":"6. WebSocket Support","text":"<p>Real-time applications require bidirectional communication, and Nexios makes it easy to set up WebSockets for handling live data exchanges.</p>"},{"location":"introduction/#example_5","title":"Example:","text":"<p><pre><code>class ChatRoom(WebSocketEndpoint):\n    async def on_connect(self, websocket: WebSocket) -&gt; None:\n        await websocket.accept()\n        await websocket.send_json({\"message\": \"Welcome to the chat!\"})\n\n    async def on_receive(self, websocket: WebSocket, message: str) -&gt; None:\n        await websocket.send_json({\"message\": f\"Received: {message}\"})\n</code></pre> Nexios supports WebSockets out of the box, allowing you to build chat applications or real-time data dashboards.</p>"},{"location":"introduction/#7-background-task-processing","title":"7. Background Task Processing","text":"<p>Long-running tasks can be handled in the background to ensure that the main thread remains responsive.</p>"},{"location":"introduction/#example_6","title":"Example:","text":"<p><pre><code>@app.route(\"/start-task\", methods=[\"POST\"])\nasync def start_task(req, res):\n    task_id = await start_long_running_task()\n    return res.json({\"message\": \"Task started!\", \"task_id\": task_id})\n</code></pre> With background tasks, you can start long-running operations like email processing or file uploads without slowing down the application.</p>"},{"location":"introduction/#8-middleware-support","title":"8. Middleware Support","text":"<p>Add custom logic to the request-response cycle with Nexios' middleware. You can perform actions like logging, rate limiting, or user authentication before or after a request is processed.</p>"},{"location":"introduction/#example_7","title":"Example:","text":"<p><pre><code>class AuthMiddleware(BaseMiddleware):\n    async def before_request(self, req, res):\n        token = req.headers.get(\"Authorization\")\n        if not token:\n            return res.json({\"error\": \"Unauthorized\"}, status=401)\n        user = await verify_token(token)\n        req.state.user = user\n        await super().before_request(req, res)\n</code></pre> Middleware allows you to easily add features like authentication or logging to every route in your app.</p>"},{"location":"introduction/#9-session-management","title":"9. Session Management","text":"<p>Nexios provides robust support for session management, allowing you to manage user sessions across multiple requests. Sessions can be stored in cookies or server-side databases.</p>"},{"location":"introduction/#example_8","title":"Example:","text":"<p><pre><code>@app.route(\"/login\", methods=[\"POST\"])\nasync def login(req, res):\n    # Authenticate user...\n    await req.session.set_session(\"username\", \"dunamis\")\n    return res.json({\"message\": \"Logged in successfully!\"})\n\n@app.route(\"/profile\", methods=[\"GET\"])\nasync def profile(req, res):\n    username = await req.session.get_session(\"username\")\n    return res.json({\"username\": username})\n</code></pre> Session management is built-in and can be customized based on your app\u2019s needs.</p>"},{"location":"introduction/#10-tortoise-orm-support","title":"10. Tortoise ORM Support","text":"<p>Tortoise ORM is an asynchronous ORM for Nexios. It supports asynchronous database queries, providing an efficient way to interact with databases in a non-blocking manner.</p>"},{"location":"introduction/#example_9","title":"Example:","text":"<p><pre><code>class Task(Model):\n    id = tortoise_fields.IntField(pk=True)\n    username = tortoise_fields.CharField(max_length=120)\n    dob = tortoise_fields.DatetimeField()\n\n@app.route(\"/task\", methods=[\"POST\"])\nasync def create_task(req, res):\n    task_data = await req.json()\n    task = await Task.create(**task_data)\n    return res.json({\"task_id\": task.id})\n</code></pre> With Tortoise ORM, you can perform database operations asynchronously, improving performance when interacting with large datasets.</p>"},{"location":"introduction/#_1","title":"Introduction","text":"<p>With Nexios, you can easily build high-performance, real-time web applications that scale efficiently. The integration of middleware, session management, Tortoise ORM, WebSockets, and background task processing makes Nexios the perfect choice for developers looking for an ASGI-based framework to handle complex, asynchronous workflows.</p> <p>From asynchronous routing and template rendering to full WebSocket support and powerful database interaction with Tortoise ORM, Nexios brings all the tools you need to build modern, scalable applications.</p> <p>Ready to take your web development to the next level? Nexios is here to supercharge your development process and make your applications faster, more scalable, and real-time ready. Let's build the future together!</p>"},{"location":"introduction/#11-validator-support","title":"11. Validator Support","text":"<p>Nexios.Validator is a powerful validation tool integrated into Nexios, designed to simplify data validation and serialization in an asynchronous context. It helps you ensure that data coming into your API or application matches specific requirements, and automatically serializes/validates it before processing.</p> <p>Example:\u00b6</p> <pre><code>from nexios.validator import Validator, fields\n\n# Define a Validator for Task data\nclass TaskValidator(Validator):\n    id = fields.Int(required=True)\n    username = fields.Str(required=True, max_length=120)\n    dob = fields.DateTime(required=True)\n\n@app.route(\"/task\", methods=[\"POST\"])\nasync def create_task(req, res):\n    task_data = await req.json()\n\n    # Validate the incoming data using Nexios.Validator\n    validator = TaskValidator()\n    result = validator.validate(task_data)\n\n    if result.errors:\n        return res.json({\"errors\": result.errors}, status=400)\n\n    # Data is valid, proceed with task creation\n    task = await Task.create(**task_data)\n    return res.json({\"task_id\": task.id})\n</code></pre> <p>With Nexios.Validator, you can efficiently validate incoming data in your asynchronous routes and endpoints. By defining validation rules on your fields (such as types, length restrictions, etc.), you ensure that only properly formatted data is processed, reducing potential errors and enhancing security.</p>"},{"location":"introduction/#key-features","title":"Key Features:","text":"<ul> <li>Field Validation: Enforce rules on the fields, such as <code>required</code>, <code>max_length</code>, <code>min_length</code>, <code>type</code>, and custom constraints.</li> <li>Error Handling: Automatically handles validation errors and provides meaningful error messages, helping you improve API reliability.</li> <li>Asynchronous Integration: Works seamlessly in asynchronous workflows, ensuring non-blocking database operations and request handling.</li> </ul>"},{"location":"introduction/#benefits","title":"Benefits:","text":"<ul> <li>Clean Code: Reduces boilerplate code for manual validation.</li> <li>Improved Security: Ensures only correctly validated data is passed to your application, reducing the chances of SQL injection or malformed data.</li> <li>Flexibility: Easily add custom validation rules to meet the specific requirements of your application.</li> </ul> <p>With Nexios.Validator, you ensure that only clean, validated data is processed by your Nexios-based applications, optimizing both reliability and performance.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"core-features/exceptions/","title":"Handling Fatal Errors in Nexios with <code>HTTPException</code>","text":"<p>In Nexios, when a fatal error occurs\u2014such as an authentication failure\u2014the framework requires raising an <code>HTTPException</code>. This ensures that the API responds with the appropriate HTTP status code and message, providing a structured and consistent error response.</p>"},{"location":"core-features/exceptions/#raising-an-httpexception-in-middleware","title":"Raising an <code>HTTPException</code> in Middleware","text":"<p>In middleware, you can raise an <code>HTTPException</code> when an error occurs, such as when authentication fails.</p>"},{"location":"core-features/exceptions/#example-authentication-middleware","title":"Example: Authentication Middleware","text":"<p><pre><code>from nexios import HTTPException\n\n# Middleware for authentication\nasync def authenticate(req, res, call_next):\n    authorized = req.headers.get(\"Authorization\") == \"Bearer VALID_TOKEN\"\n\n    if not authorized:\n        raise HTTPException(401, detail=\"Unauthorized\")\n\n    return await call_next(req, res)\n</code></pre> Here, if the <code>Authorization</code> header is missing or invalid, an <code>HTTPException</code> with a <code>401 Unauthorized</code> status code is raised.</p>"},{"location":"core-features/exceptions/#handling-httpexception","title":"Handling <code>HTTPException</code>","text":"<p>To catch and handle <code>HTTPException</code>, use <code>app.add_exception_handler</code>. This ensures a uniform error response.</p>"},{"location":"core-features/exceptions/#example-handling-exceptions-globally","title":"Example: Handling Exceptions Globally","text":"<p><pre><code># Exception handler\nasync def handle_exception(req, res, exc):\n    if exc.status_code == 401:\n        res.status_code = 401\n        res.json({\"error\": \"Unauthorized\", \"message\": exc.detail})\n    else:\n        res.status_code = exc.status_code\n        res.json({\"error\": \"An error occurred\", \"message\": exc.detail})\n\n# Register exception handler\napp.add_exception_handler(handle_exception)\n</code></pre> This function ensures that all <code>HTTPException</code> responses are formatted consistently.</p>"},{"location":"core-features/exceptions/#creating-custom-exceptions","title":"Creating Custom Exceptions","text":"<p>For better code organization, you can create custom exception classes that extend <code>HTTPException</code>. This allows you to define reusable error types.</p>"},{"location":"core-features/exceptions/#example-custom-authentication-exception","title":"Example: Custom Authentication Exception","text":"<pre><code>class AuthenticationError(HTTPException):\n    def __init__(self, detail=\"Authentication failed\"):\n        super().__init__(status_code=401, detail=detail)\n</code></pre> <p>Now, instead of raising <code>HTTPException</code> manually, you can do: <pre><code>raise AuthenticationError()\n</code></pre> This simplifies error handling and keeps the code clean.</p>"},{"location":"core-features/exceptions/#example-handling-multiple-custom-exceptions","title":"Example: Handling Multiple Custom Exceptions","text":"<p>You can register exception handlers for specific custom exceptions.</p> <p><pre><code>class ForbiddenError(HTTPException):\n    def __init__(self, detail=\"Access Denied\"):\n        super().__init__(status_code=403, detail=detail)\n\nclass NotFoundError(HTTPException):\n    def __init__(self, detail=\"Resource not found\"):\n        super().__init__(status_code=404, detail=detail)\n\nasync def handle_auth_error(req, res, exc):\n    res.status_code = 401\n    res.json({\"error\": \"Unauthorized\", \"message\": exc.detail})\n\nasync def handle_forbidden_error(req, res, exc):\n    res.status_code = 403\n    res.json({\"error\": \"Forbidden\", \"message\": exc.detail})\n\nasync def handle_not_found_error(req, res, exc):\n    res.status_code = 404\n    res.json({\"error\": \"Not Found\", \"message\": exc.detail})\n\napp.add_exception_handler(AuthenticationError, handle_auth_error)\napp.add_exception_handler(ForbiddenError, handle_forbidden_error)\napp.add_exception_handler(NotFoundError, handle_not_found_error)\n</code></pre> Now, when you raise <code>AuthenticationError</code>, <code>ForbiddenError</code>, or <code>NotFoundError</code>, Nexios will automatically use the corresponding handler.</p>"},{"location":"core-features/middleware/","title":"Middleware","text":"<p>Middleware works after/before Handler. We can get Request before dispatching or manipulate Response after dispatching.</p> <p>Here\u2019s a rephrased version of the definition of middleware and handlers, with improved clarity and flow:</p>"},{"location":"core-features/middleware/#definition-of-middleware-and-handlers","title":"Definition of Middleware and Handlers","text":"<ol> <li>Handler:</li> <li>A handler is a function that processes an HTTP request and must return a <code>Response</code> object.</li> <li>Only one handler is invoked per request, based on the route and HTTP method.</li> </ol> <pre><code> async def log_request(req,res):\n     return res.text(\"Hanler from nexios\")\n</code></pre> <ol> <li>Middleware:</li> <li>A middleware is a function that processes a request before it reaches the handler.</li> <li>Middleware functions do not return a value. Instead, they call <code>await next()</code> to pass control to the next middleware or the final handler.</li> <li>Multiple middleware functions can be chained together to perform tasks like authentication, logging, or request modification.</li> </ol> <pre><code> async def log_request(req,res, call_next):\n     #run before handler\n     await call_next()\n     #run after handler\n</code></pre> <ol> <li>Registration:</li> <li>Middleware and handlers can be registered using:<ul> <li><code>app.add_middleware(middleware_handler)</code>: Registers middleware for all routes.</li> </ul> </li> </ol>"},{"location":"core-features/middleware/#key-differences","title":"Key Differences","text":"Aspect Handler Middleware Purpose Processes the request and sends a response. Processes the request before it reaches the handler. Return Value Must return a <code>Response</code> object. Does not return a value; calls <code>await next()</code> to proceed. Invocation Only one handler is called per request. Multiple middleware functions can be chained."},{"location":"core-features/middleware/#execution-order","title":"Execution order","text":"<p>The order in which Middleware is executed is determined by the order in which it is registered. The process before the next of the first registered Middleware is executed first, and the process after the next is executed last. See below.</p> <pre><code>from nexios import get_application()\n\napp = get_application()\n\nasync def middleware_1(request,response, call_next):\n    print(\"middleware 1 start\")\n    response = await call_next()  # Proceed to the next middleware or handler\n    print(\"middleware 1 end\")\n    return response\n\nasync def middleware_2(request,response, call_next):\n    print(\"middleware 2 start\")\n    response = await call_next()  # Proceed to the next middleware or handler\n    print(\"middleware 2 end\")\n    return response\n\nasync def middleware_3(request,response, call_next):\n    print(\"middleware 3 start\")\n    response = await call_next()  # Proceed to the next middleware or handler\n    print(\"middleware 3 end\")\n    return response\n\n@app.get(\"/\")\nasync def handler(request,response):\n    print(\"handler\")\n    return Response(body=\"Hello!\", status_code=200)\napp.add_middleware(middleware_1)\napp.add_middleware(middleware_2)\napp.add_middleware(middleware_3)\n</code></pre> <p>Result is the following</p> <pre><code>middleware 1 start\n    middleware 2 start\n        middleware 3 start\n            handler\n        middleware 3 end\n    middleware 2 end\nmiddleware 1 end\n</code></pre>"},{"location":"core-features/middleware/#modify-the-response-after-next","title":"Modify the Response After <code>next()</code>","text":"<p>Middleware in Nexio can not only process requests before they reach the handler but also modify responses after the handler has processed the request. This is achieved by capturing the response returned by <code>await next(request)</code> and making changes to it before returning it further up the middleware chain.</p>"},{"location":"core-features/middleware/#how-it-works","title":"How It Works","text":"<ol> <li>Capture the Response:</li> <li>When <code>await call_next()</code> is called, the middleware waits for the next middleware or handler to process the request and return a response.</li> <li> <p>The response is then captured and can be modified.</p> </li> <li> <p>Modify the Response:</p> </li> <li> <p>You can modify the response's body, headers, status code, or any other property before returning it.</p> </li> <li> <p>Return the Modified Response:</p> </li> <li>The modified response is returned to the previous middleware or sent back to the client.</li> </ol>"},{"location":"core-features/middleware/#example-adding-a-custom-header","title":"Example: Adding a Custom Header","text":"<p>Here\u2019s an example of a middleware that adds a custom header to the response:</p> <pre><code>@app.use\nasync def add_header_middleware(request,response, call_next):\n    response = await call_next()\n\n    # Modify the response by adding a custom header\n    response.headers[\"X-Custom-Header\"] = \"Modified by Middleware\"\n\n    return response\n</code></pre>"},{"location":"core-features/middleware/#example-logging-response-status","title":"Example: Logging Response Status","text":"<p>Here\u2019s an example of a middleware that logs the response status code:</p> <pre><code>@app.use\nasync def log_status_middleware(request,response, call_next):\n    # Proceed to the next middleware or handler\n    response = await call_next()\n\n    # Log the response status code\n    print(f\"Response Status: {response.status_code}\")\n\n    return response\n</code></pre>"},{"location":"core-features/middleware/#key-points","title":"Key Points","text":"<ul> <li>Flexibility: Middleware can modify responses to add headers, change the body, or even replace the entire response.</li> <li>Order Matters: Since middlewares are executed in reverse order after the handler, modifications made in earlier middlewares will take precedence.</li> <li>Use Cases:</li> <li>Adding security headers (e.g., <code>Content-Security-Policy</code>).</li> <li>Logging response details.</li> <li>Transforming the response body (e.g., compressing data).</li> </ul>"},{"location":"core-features/middleware/#important-note","title":"Important Note","text":"<p>When modifying responses, ensure that the changes are consistent with the application's requirements and do not break the client's expectations. For example, avoid modifying the response body if the client expects a specific format (e.g., JSON).</p> <p>This note explains how middleware can modify responses after <code>await next(request)</code> and provides practical examples. Let me know if you need further clarification or additional examples!</p> <p>Here\u2019s a rewritten version of the previous note, focusing on the class-based middleware approach where the user can decide when to call <code>next</code>. This version is concise, clear, and structured for better readability.</p>"},{"location":"core-features/middleware/#class-based-middleware-in-nexio","title":"Class-Based Middleware in Nexio","text":"<p>In Nexio, you can create class-based middlewares by inheriting from a <code>BaseMiddleware</code> class. This approach provides a structured way to define middleware logic, with the flexibility to decide when to call <code>next</code> to proceed to the next middleware or handler.</p>"},{"location":"core-features/middleware/#basemiddleware-class","title":"BaseMiddleware Class","text":"<p>The <code>BaseMiddleware</code> class serves as a template for creating custom middlewares. It includes two key methods: 1. <code>process_request(request, next)</code>: Executed before the request reaches the handler or the next middleware. The user can decide when to call <code>next()</code>. 2. <code>process_response(request, response)</code>: Executed after the request has been processed, allowing modification of the response before it is returned to the client.</p>"},{"location":"core-features/middleware/#key-features","title":"Key Features","text":"<ol> <li>Flexibility:</li> <li>The user decides when to call <code>call_next()</code> in <code>process_request</code>, enabling custom logic like short-circuiting or conditional processing.</li> <li>Separation of Concerns:</li> <li><code>process_request</code> handles pre-processing of the request.</li> <li><code>process_response</code> handles post-processing of the response.</li> <li>Reusability:</li> <li>Middleware logic can be reused across multiple routes or applications.</li> </ol>"},{"location":"core-features/middleware/#creating-a-custom-middleware","title":"Creating a Custom Middleware","text":"<p>To create a custom middleware, inherit from <code>BaseMiddleware</code> and override the <code>process_request</code> and <code>process_response</code> methods.</p>"},{"location":"core-features/middleware/#example-logging-middleware","title":"Example: Logging Middleware","text":"<p>This middleware logs the request method and path before processing and logs the response status code after processing.</p> <pre><code>from nexios.base import BaseMiddleware\nclass LoggingMiddleware(BaseMiddleware):\n    async def process_request(self, request, next):\n        print(f\"Request: {request.method} {request.path}\")\n        # Call next() to proceed to the next middleware or handler\n        return await next(request)\n\n    async def process_response(self, request, response):\n        print(f\"Response: {response.status_code}\")\n        return response\n</code></pre>"},{"location":"core-features/middleware/#example-authentication-middleware","title":"Example: Authentication Middleware","text":"<p>This middleware checks for an API key in the request headers before processing and short-circuits the request cycle if the key is invalid.</p> <pre><code>from nexios.base import BaseMiddleware\nclass AuthMiddleware(BaseMiddleware):\n    async def process_request(self, request, next):\n        api_key = request.headers.get(\"x-api-key\")\n        if api_key != \"your-secret-key\":\n            # Short-circuit the request cycle and return a 401 response\n            return Response(body=\"Unauthorized\", status_code=401)\n        # Call next() to proceed to the next middleware or handler\n        return await next(request)\n</code></pre>"},{"location":"core-features/middleware/#registering-class-based-middleware","title":"Registering Class-Based Middleware","text":"<p>To use a class-based middleware, instantiate it and register it with the Nexio app using <code>app.use</code>.</p> <pre><code>app = get_application()\n\napp.add_middleware(LoggingMiddleware())\napp.add_middleware(AuthMiddleware())\n\n# Define a route\n@app.get(\"/\")\nasync def handler(request, response):\n    return response.json(body=\"Hello, World!\", status_code=200)\n</code></pre>"},{"location":"core-features/middleware/#execution-flow","title":"Execution Flow","text":"<ol> <li>Request Phase:</li> <li>The <code>process_request</code> method is called.</li> <li>The user can decide when to call <code>next()</code> to proceed to the next middleware or handler.</li> <li> <p>If <code>next()</code> is not called, the middleware can short-circuit the request cycle by returning a <code>Response</code> directly.</p> </li> <li> <p>Response Phase:</p> </li> <li>The <code>process_response</code> method is called after <code>next()</code> has been called.</li> <li>The user can modify the response before it is returned to the client.</li> </ol>"},{"location":"core-features/middleware/#advantages","title":"Advantages","text":"<ol> <li>Control Over Flow:</li> <li>The user decides when to proceed to the next middleware or handler.</li> <li>Modularity:</li> <li>Middleware logic is encapsulated in reusable classes.</li> <li>Separation of Concerns:</li> <li>Pre-processing and post-processing logic are clearly separated.</li> </ol>"},{"location":"core-features/middleware/#example-output","title":"Example Output","text":"<p>For the <code>LoggingMiddleware</code> and <code>AuthMiddleware</code> example: - If the API key is valid:   <pre><code>Request: GET /\nResponse: 200\n</code></pre> - If the API key is invalid:   <pre><code>Request: GET /\nResponse: 401\n</code></pre></p> <p>This note explains how to create and use class-based middlewares in Nexio, with examples and a clear explanation of the execution flow. Let me know if you need further clarification!</p>"},{"location":"core-features/request-object/","title":"Request Object","text":"<p>Request Object Documentation for Nexios   Applications</p>"},{"location":"core-features/request-object/#overview","title":"Overview","text":"<p>The Request object in Nexios represents an HTTP request sent to the server. It encapsulates all the data that is sent by the client, such as headers, query parameters, form data, cookies, and more. The Request object is a central part of the request-response cycle in Nexios and provides various methods to access and manipulate the incoming data.</p>"},{"location":"core-features/request-object/#path_params","title":"path_params","text":"<p> In Nexios, path parameters are typically defined in the route path using placeholders, like  /user/{user_id}. When a request is made to this route, the value for user_id will be captured and can be accessed via request.path_params.</p> <pre><code>from nexios import get_application\n\napp = get_application()\n\n#Get path param\n@app.get('/user/{user_id}')\nasync def get_user(req):\n    user_id = request.path_params.user_id  # Access path parameter 'user_id'\n    return return res.text('User ID is: {user_id}')\n\n#Get all path params at ounce\n@app.get('/user/{post_id}/comment/{comment_id}')\nasync def get_user(req):\n    path_prams = request.path_params()  # return parameters as a dict'\n    return return res.json(path_prams)\n</code></pre>"},{"location":"core-features/request-object/#query_param","title":"query_param()","text":"<p>Get the values of path parameters.</p> <p>Query parameters are the key-value pairs in the URL, typically found after the ? symbol. For example, in the URL /search?query=nexios&amp;page=2, query and page are query parameters. In Nexios, you would access these query parameters through the request object, often using methods or attributes designed for extracting them. For example, you might retrieve a parameter like request.query[\"query\"] to get the value of query.</p> <pre><code>from nexios import get_application\n\napp = get_application()\n\n#Get query param\n@app.get('/user')\ndef user(req, res):\n    user_id = request.query_params.get('id')  # Access query parameters\n    return res.json({\"user_id\":user_id})\n\n\n#Get query all params\n@app.get('/user')\ndef user(req, res):\n    query_params = request.query_params()  # Access query parameters\n    return res.json(query_params)\n</code></pre>"},{"location":"core-features/request-object/#headers","title":"headers()","text":"<p>  Headers in HTTP are like the notes that come with a package when it's sent. They provide important details about the package (data), such as its type, how it should be handled, or any special instructions, like authentication info.  For example:  `Content-Type` tells the server what kind of data the client is sending, like saying, \"I'm sending a JSON file.\"  `Authorization` might be like a key or password, letting the server know who the client is. User-Agent identifies which browser or app is making the request. Accept tells the server what type of response the client wants, like asking, \"Can you send me that in JSON format?\" </p> <pre><code>@app.get(\"/headers\")\nasync def route_handler(req, res):\n\n    print(req.headers['key']) #return the Value for the key else raise None`\n    print(req.headers.items()) #return a key value tuple in a list [(key,value),(key,value)]\n</code></pre>"},{"location":"core-features/request-object/#body","title":"body()","text":"<p> This property asynchronously retrieves the raw body content of the request. The body is typically the data sent by the client (e.g., form data, JSON). The body is retrieved in chunks, and the method ensures that all data is read before returning it.</p> <pre><code>@app.post(\"/endpoint\")\nasync def route_handler(req, res):\n  body = await request.body()\n  print(body)\n  return res.json({\"message\":\"text received succesfully\"})\n</code></pre>"},{"location":"core-features/request-object/#body_1","title":"body()","text":"<p> This property asynchronously parses Parses the request body of type application/json  as JSON. It tries to decode the body into a Python dictionary. If the body is not valid JSON or cannot be decoded, it returns an empty dictionary. This is useful for APIs that expect JSON input.</p> <pre><code>@app.post(\"/endpoint\")\nasync def route_handler(req, res):\n  body = await request.json\n  print(body)\n  return res.json({\"message\":\"text received succesfully\"})\n</code></pre>"},{"location":"core-features/request-object/#form_data","title":"form_data()","text":"<p>This property asynchronously parses the request body as form data. It handles both multipart/form-data (used for file uploads) and application/x-www-form-urlencoded (used for standard form submissions). The method ensures that both types are handled properly and returns the parsed form data as a dictionary</p> <pre><code>@app.post(\"/endpoint\")\nasync def route_handler(req, res):\n  body = await request.form_data\n  return response.json({\"text\":\"success\"})\n</code></pre>"},{"location":"core-features/request-object/#stream","title":"stream()","text":"<p>This method asynchronously yields chunks of the request body. It is useful for handling large requests that are too big to fit into memory at once. This method can be used to stream data from the client in smaller parts, which can be processed incrementally.</p> <pre><code>@app.post(\"/endpoint\")\nasync def route_handler(req, res):\n\n    # Start streaming the request body\n    chunked_data = []\n\n    async for chunk in await request.stream():\n        # Collecting chunks to simulate processing\n        chunked_data.append(chunk.decode())\n\n    # Join all the chunks and return a response\n    full_data = ''.join(chunked_data)\n    return response.text(\"Data recieve successfully\")\n</code></pre>"},{"location":"core-features/request-object/#content-type","title":"content-type","text":"<p>Content-Type is an HTTP header that specifies the format of the data being sent, helping the server or client know how to interpret it (e.g., JSON, HTML, or file uploads).</p> <pre><code>@app.get(\"/endpoint\")\nasync def route_handler(req, res):\n\n  print(request.content_type) # Returns the MIME type of the request content.\n</code></pre>"},{"location":"core-features/request-object/#client","title":"client()","text":"<p>The <code>.client()</code> method returns a tuple with the client's host (IP address or hostname) and port (connection port). It's useful for logging, identifying request origins, or applying specific rules.</p> <pre><code>@app.get(\"/endpoint\")\nasync def route_handler(req, res):\n\n  print(request.client()) #Returns client information as a tuple of (host, port).\n</code></pre>"},{"location":"core-features/request-object/#cookies","title":"cookies","text":"<p>Cookies are small pieces of data stored by the browser on a user's device. They are sent between the server and client with each HTTP request, allowing the server to remember user preferences, authentication details, or session information. Cookies can be persistent (remaining for a specified duration) or session-based (deleted when the browser is closed). They are often used for things like keeping users logged in or tracking user behavior across sessions. in nexio thie attr is typically stores as dict and access as same .</p> <pre><code>@app.route(\"/user-session\")\nasync def route_handler(request, response):\n\n    print(request.cookies['key']) #return the Value for the key else raise KeyError`\n    print(request.cookies.items()) #return a key value tuple in a list [(key,value),(key,value)]\n</code></pre>"},{"location":"core-features/request-object/#method","title":"method","text":"<p>The method attribute provides the HTTP method used for the request. This is typically one of the standard HTTP methods such as GET, POST, PUT, DELETE, PATCH, HEAD, or OPTIONS.</p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(req, res):\n  if req.method == \"POST\":\n      create_user()\n      return res.json({\"success\":\"user created succesfully\"})\n  return res.json(get_user_profile())\n</code></pre>"},{"location":"core-features/request-object/#path","title":"path","text":"<p>The path attribute provides the path of the request URL. This is the part of the URL that comes after the domain name and port.</p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(req, res):\n   print(req.path)\n   ...\n</code></pre>"},{"location":"core-features/request-object/#files","title":"files","text":"<p>The files attribute provides access to uploaded files in the request. This is typically used when handling multipart/form-data requests, such as file uploads.</p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(req, res):\n    files = await req.files\n    for field_name, file in files.items():\n        print(f\"Field Name: {field_name}, File Name: {file.filename}\")\n   ...\n</code></pre>"},{"location":"core-features/request-object/#client_1","title":"client","text":"<p>The client attribute provides information about the client (user) making the request. It returns a tuple containing the client's host (IP address) and port. <pre><code>@app.route(\"/client-info\")\nasync def client_info_handler(req, response):\n    client = req.client\n    if client:\n        host, port = client\n        print(f\"Client Host: {host}, Client Port: {port}\")\n    else:\n        print(\"No client information available.\")\n</code></pre></p>"},{"location":"core-features/request-object/#build_absolute_uri","title":"build_absolute_uri","text":"<p>The build_absolute_uri method constructs a fully qualified absolute URI using the base URL of the request and an optional path or query parameters. <pre><code>@app.route(\"/client-info\")\nasync def client_info_handler(req, response):\n    absolute_uri = request.build_absolute_uri(\"/example\", {\"param\": \"value\"})\n    print(absolute_uri) # e.g., \"https://example.com/example?param=value\"\n</code></pre></p>"},{"location":"core-features/response-object/","title":"Response Object","text":""},{"location":"core-features/response-object/#nexioresponse-class","title":"<code>NexioResponse</code> Class","text":"<p>The <code>NexioResponse</code> class is a fluent interface for creating and customizing HTTP responses in a Nexio application. It supports various response types, including plain text, JSON, HTML, files, streaming, and redirects. It also provides methods for setting headers, cookies, and caching behavior.</p> <p>  The NexioResponse class is a fluent interface and abstraction layer that simplifies the creation and customization of HTTP responses in a Nexio application. Instead of directly instantiating specific response classes like Response, JSONResponse, FileResponse, etc., developers can use NexioResponse to handle all response types in a consistent and intuitive way.  <p></p>"},{"location":"core-features/response-object/#methods","title":"Methods","text":""},{"location":"core-features/response-object/#sendcontent-any-status_code-optionalint-none-headers-dictstr-any","title":"<code>send(content: Any, status_code: Optional[int] = None, headers: Dict[str, Any] = {})</code>","text":"<p>Sends a plain text or HTML response.</p> <ul> <li>Parameters:</li> <li><code>content</code>: The response body (can be any type).</li> <li><code>status_code</code>: The HTTP status code (default: <code>200</code>).</li> <li><code>headers</code>: Additional headers to include in the response.</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.send(\"Hello, World!\", status_code=200)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#textcontent-status_codeheaders","title":"<code>text(content, status_code,headers)</code>","text":"<p>Sends a plain text response.</p> <ul> <li>Parameters:</li> <li><code>content</code>: The response body (can be <code>str</code>, <code>dict</code>, <code>list</code>, etc.).</li> <li><code>status_code</code>: The HTTP status code (default: <code>200</code>).</li> <li><code>headers</code>: Additional headers to include in the response.</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.text(\"Hello, World!\", status_code=200)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#jsoncontent-status_codeheaders","title":"<code>json(content, status_code,headers)</code>","text":"<p>Sends a JSON response.</p> <ul> <li>Parameters:</li> <li><code>data</code>: The JSON-serializable data to send.</li> <li><code>status_code</code>: The HTTP status code (default: <code>200</code>).</li> <li><code>headers</code>: Additional headers to include in the response.</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.json({\"message\": \"Hello, World!\"}, status_code=200)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#emptystatus_code-headers","title":"<code>empty(status_code headers)</code>","text":"<p>Sends an empty response with no body.</p> <ul> <li>Parameters:</li> <li><code>status_code</code>: The HTTP status code (default: <code>200</code>).</li> <li><code>headers</code>: Additional headers to include in the response.</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.empty(status_code=204)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#htmlcontent-status_code-headers","title":"<code>html(content, status_code ,headers)</code>","text":"<p>Sends an HTML response.</p> <ul> <li>Parameters:</li> <li><code>content</code>: The HTML content to send.</li> <li><code>status_code</code>: The HTTP status code (default: <code>200</code>).</li> <li><code>headers</code>: Additional headers to include in the response.</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.html(\"&lt;h1&gt;Hello, World!&lt;/h1&gt;\", status_code=200)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#filepath-filename-content_disposition_type","title":"<code>file(path, filename, content_disposition_type)</code>","text":"<p>Sends a file as a response.</p> <ul> <li>Parameters:</li> <li><code>path</code>: The path to the file on the server.</li> <li><code>filename</code>: The name of the file to send (default: the file's basename).</li> <li><code>content_disposition_type</code>: The type of content disposition (<code>\"attachment\"</code> or <code>\"inline\"</code>).</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.file(\"/path/to/file.pdf\", filename=\"document.pdf\")\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#streamiterator-content_type","title":"<code>stream(iterator, content_type)</code>","text":"<p>Sends a streaming response.</p> <ul> <li>Parameters:</li> <li><code>iterator</code>: An iterator that yields chunks of data (<code>str</code> or <code>bytes</code>).</li> <li><code>content_type</code>: The content type of the stream (default: <code>\"text/plain\"</code>).</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>async def generate_data():\n    yield \"Hello, \"\n    yield \"World!\"\nresponse.stream(generate_data())\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#redirecturl-status_code","title":"<code>redirect(url ,status_code)</code>","text":"<p>Sends a redirect response.</p> <ul> <li>Parameters:</li> <li><code>url</code>: The URL to redirect to.</li> <li><code>status_code</code>: The HTTP status code (default: <code>302</code>).</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.redirect(\"/new-location\", status_code=302)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#statusstatus_code","title":"<code>status(status_code)</code>","text":"<p>Sets the HTTP status code for the response.</p> <ul> <li>Parameters:</li> <li><code>status_code</code>: The HTTP status code.</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.status(404)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#headerkey-value","title":"<code>header(key, value)</code>","text":"<p>Sets a header in the response.</p> <ul> <li>Parameters:</li> <li><code>key</code>: The header name.</li> <li><code>value</code>: The header value.</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.header(\"X-Custom-Header\", \"value\")\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#set_cookiekey-value-max_age-expires-path-domain-secure-httponly-samesite","title":"<code>set_cookie(key, value , max_age, expires, path, domain, secure, httponly, samesite)</code>","text":"<p>Sets a cookie in the response.</p> <ul> <li>Parameters:</li> <li><code>key</code>: The cookie name.</li> <li><code>value</code>: The cookie value.</li> <li><code>max_age</code>: The maximum age of the cookie in seconds.</li> <li><code>expires</code>: The expiration date of the cookie.</li> <li><code>path</code>: The path for the cookie (default: <code>\"/\"</code>).</li> <li><code>domain</code>: The domain for the cookie.</li> <li><code>secure</code>: Whether the cookie is secure (default: <code>True</code>).</li> <li><code>httponly</code>: Whether the cookie is HTTP-only (default: <code>False</code>).</li> <li><code>samesite</code>: The <code>SameSite</code> attribute for the cookie.</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.set_cookie(\"session_id\", \"12345\", max_age=3600)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#delete_cookiekey-value-max_age-expires-path-domain-secure-httponly-samesite","title":"<code>delete_cookie(key, value , max_age, expires, path, domain, secure, httponly, samesite)</code>","text":"<p>Deletes a cookie by setting its expiration to the past.</p> <ul> <li>Parameters:</li> <li><code>key</code>: The cookie name.</li> <li><code>value</code>: The cookie value (optional).</li> <li><code>max_age</code>: The maximum age of the cookie in seconds (optional).</li> <li><code>expires</code>: The expiration date of the cookie (optional).</li> <li><code>path</code>: The path for the cookie (default: <code>\"/\"</code>).</li> <li><code>domain</code>: The domain for the cookie (optional).</li> <li><code>secure</code>: Whether the cookie is secure (default: <code>False</code>).</li> <li><code>httponly</code>: Whether the cookie is HTTP-only (default: <code>False</code>).</li> <li><code>samesite</code>: The <code>SameSite</code> attribute for the cookie (optional).</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.delete_cookie(\"session_id\")\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#cachemax_age-private","title":"<code>cache(max_age, private)</code>","text":"<p>Enables caching for the response.</p> <ul> <li>Parameters:</li> <li><code>max_age</code>: The maximum age of the cache in seconds (default: <code>3600</code>).</li> <li><code>private</code>: Whether the cache is private (default: <code>True</code>).</li> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.cache(max_age=3600)\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#no_cache","title":"<code>no_cache()</code>","text":"<p>Disables caching for the response.</p> <ul> <li>Returns: <code>self</code> (for method chaining).</li> <li>Example:   <pre><code>response.no_cache()\n</code></pre></li> </ul>"},{"location":"core-features/response-object/#example-usage","title":"Example Usage","text":"<pre><code>@app.route(\"/client-info\")\nasync def client_info_handler(req, response):\n    response.set_cookie(\"session_id\", \"12345\", max_age=3600)\n    response.header(\"X-Custom-Header\", \"value\")\n    response.cache(max_age=3600)\n    response.json({\"message\": \"Hello, World!\"}, status_code=200)\n</code></pre>"},{"location":"core-features/routing/","title":"Routing","text":""},{"location":"core-features/routing/#routing-in-nexio","title":"Routing in Nexio","text":"<p>Routing is a core feature of Nexio that allows you to define how incoming HTTP requests are handled based on the request path and HTTP method. Nexio provides a flexible and powerful routing system, including support for path parameters, route validators, and regex-based paths. Additionally, Nexio supports routers for organizing routes into modular components.</p>"},{"location":"core-features/routing/#basic-routing","title":"Basic Routing","text":"<p>Routes are defined using the <code>@app.HTTP_METHOD</code> decorators, where <code>HTTP_METHOD</code> can be <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>, etc.</p>"},{"location":"core-features/routing/#example-basic-route","title":"Example: Basic Route","text":"<pre><code>from nexios import get_application\nfrom nexios.http import  Request, Response\n\napp = get_application()\n\n@app.get(\"/hello\")\nasync def hello_handler(request: Request, response :Response):\n    return response.text(\"Hello, World!\", status_code=200)\n\n#or\n@app.route(\"/hello\",allowed_method=[\"GET\"])\nasync def hello_handler(request: Request, response :Response):\n    return response.text(\"Hello, World!\", status_code=200)\n</code></pre> <ul> <li>Path: <code>/hello</code></li> <li>HTTP Method: <code>GET</code></li> <li>Handler: <code>hello_handler</code></li> </ul>"},{"location":"core-features/routing/#adding-routes-programmatically","title":"Adding Routes Programmatically","text":"<p>You can also add routes programmatically using the <code>add_route</code> method on the <code>app</code> or <code>router</code> object. This is useful for dynamic route registration or when working with external configurations.</p>"},{"location":"core-features/routing/#example-using-add_route","title":"Example: Using <code>add_route</code>","text":"<pre><code>from nexios import get_application\nfrom nexios.http import  Request, Response\n\napp = get_application()\n\nasync def hello_handler(request: Request, response :Response):\n    return response.text(\"Hello, World!\", status_code=200)\n\n\n# Add a route programmatically\napp.add_route(Routes(\"/hello\", hello_handler, methods=[\"GET\"]))\n</code></pre> <ul> <li>Path: <code>/hello</code></li> <li>HTTP Method: <code>GET</code></li> <li>Handler: <code>hello_handler</code></li> </ul>"},{"location":"core-features/routing/#path-parameters","title":"Path Parameters","text":"<p>Path parameters allow you to capture dynamic values from the URL. They are defined using curly braces <code>{}</code>.</p>"},{"location":"core-features/routing/#example-path-parameters","title":"Example: Path Parameters","text":"<pre><code>@app.get(\"/user/{user_id}\")\nasync def user_handler(request: Request, response :Response):\n    user_id = request.path_params.user_id\n    return response.text(f\"User ID: {user_id}\", status_code=200)\n</code></pre> <ul> <li>Path: <code>/user/{user_id}</code></li> <li>Captured Value: <code>user_id</code> is passed to the handler as an argument.</li> </ul>"},{"location":"core-features/routing/#adding-validators-to-routes","title":"Adding Validators to Routes","text":"<p>Validators ensure that path parameters meet specific criteria (e.g., type, format). Nexio supports built-in and custom validators.</p>"},{"location":"core-features/routing/#example-route-with-validators","title":"Example: Route with Validators","text":"<pre><code>from nexios.validators import IsInt\n\n@app.get(\"/user/{user_id}\",validator={\"user_id\":int})\nasync def user_handler(request: Request, response :Response):\n    user_id = request.path_params.user_id\n    return response.text(f\"User ID: {user_id}\", status_code=200)\n</code></pre> <ul> <li>Validator: <code>int</code> ensures that <code>user_id</code> is an integer.</li> <li>If the validation fails, Nexio automatically returns a <code>422 Unprocessable</code> response.</li> </ul>"},{"location":"core-features/routing/#regex-in-route-paths","title":"Regex in Route Paths","text":"<p>Regex can be used to define complex path patterns. This is useful for advanced routing requirements.</p>"},{"location":"core-features/routing/#example-regex-in-route-path","title":"Example: Regex in Route Path","text":"<pre><code>@app.get(r\"/post/{post_id:\\d+}\")\nasync def post_handler(request: Request, response :Response):\n    user_id = request.path_params.user_id\n    return response.text(f\"User ID: {user_id}\", status_code=200)\n</code></pre> <ul> <li>Regex: <code>\\d+</code> ensures that <code>post_id</code> is a sequence of digits.</li> <li>Path: <code>/post/123</code> (valid), <code>/post/abc</code> (invalid).</li> </ul>"},{"location":"core-features/routing/#routers","title":"Routers","text":"<p>Routers allow you to organize routes into modular components. This is especially useful for large applications with multiple routes.</p>"},{"location":"core-features/routing/#example-using-routers","title":"Example: Using Routers","text":"<pre><code>from nexios import Router\n\n# Create a router\nuser_router = Router(prefix=\"/user\") #prefix is optional\n\n# Define routes in the router\n@user_router.get(\"/profile\")\nasync def profile_handler(request: Request, response :Response):\n    return Response(body=\"User Profile\", status_code=200)\n\n@user_router.get(\"/settings\")\nasync def settings_handler(request: Request, response :Response):\n   return response.text(f\"User ID: {user_id}\", status_code=200)\n\n\n# Mount the router under a prefix\napp.mount_router(user_router)\n</code></pre> <ul> <li>Router Paths:</li> <li><code>/user/profile</code></li> <li><code>/user/settings</code></li> <li>Benefits:</li> <li>Modularizes route definitions.</li> <li>Simplifies route management in large applications.</li> </ul>"},{"location":"core-features/routing/#adding-routes-to-routers-programmatically","title":"Adding Routes to Routers Programmatically","text":"<p>You can also add routes to routers programmatically using the <code>add_route</code> method.</p>"},{"location":"core-features/routing/#example-adding-routes-to-a-router","title":"Example: Adding Routes to a Router","text":"<pre><code>from nexios.routing import Router Routes\nfrom nexios.http import Request, Response\nuser_router = Router()\n\nasync def profile_handler(request: Request, response :Response):\n    return response.text(\"User Profile\", status_code=200)\n\nasync def settings_handler(request: Request, response :Response):\n    return response.text(\"User Settings\", status_code=200)\n\nuser_router.add_route(Routes(\"/profile\", profile_handler, methods=[\"GET\"]))\nuser_router.add_route(Routes(\"/settings\", settings_handler, methods=[\"GET\"]))\n\napp.mount_router(user_router)\n</code></pre>"},{"location":"core-features/routing/#advanced-routing-features","title":"Advanced Routing Features","text":"<ol> <li>Wildcard Routes:</li> <li>Use <code>*</code> to match any path segment.</li> <li> <p>Example: <code>/files/*</code> matches <code>/files/a</code>, <code>/files/a/b</code>, etc.</p> </li> <li> <p>Optional Parameters:</p> </li> <li>Use <code>?</code> to make a path segment optional.</li> <li> <p>Example: <code>/user/{user_id?}</code> matches <code>/user</code> and <code>/user/123</code>.</p> </li> <li> <p>Custom Validators:</p> </li> <li> <p>Create custom validators by subclassing <code>Validator</code> and implementing the <code>validate</code> method.</p> </li> <li> <p>Route Prefixing:</p> </li> <li>Apply a common prefix to a group of routes using <code>Router</code> or <code>RouteGroup</code>.</li> </ol>"},{"location":"core-features/routing/#example-complete-routing-setup","title":"Example: Complete Routing Setup","text":"<pre><code>from nexios import Nexio, Router, Request, Response, Routes\nfrom nexios.validators import IsInt\n\napp = Nexio()\n\n@app.get(\"/hello\")\nasync def hello_handler(request: Request, response :Response):\n    return response.text(body=\"Hello, World!\", status_code=200)\n\n@app.get(\"/user/{user_id}\")\nasync def user_handler(request: Request, response :Response):\n    user_id = request.path_params.user_id\n    return response.text(f\"User ID: {user_id}\", status_code=200)\n\n# Router example\nuser_router = Router()\n\n@user_router.get(\"/profile\")\nasync def profile_handler(request: Request, response :Response):\n    return response.text(\"User Profile\", status_code=200)\n\n@user_router.get(\"/settings\")\nasync def settings_handler(request: Request):\n    return response.text(\"User Settings\", status_code=200)\n\n\n\n# Adding routes programmatically\nasync def about_handler(request: Request, response :Response):\n    return Response(body=\"About Us\", status_code=200)\n\napp.add_route(Routes(\"/about\", about_handler, methods=[\"GET\"]))\n</code></pre>"},{"location":"core-features/routing/#summary","title":"Summary","text":"<ul> <li>Basic Routes: Define routes using <code>@app.HTTP_METHOD</code>.</li> <li>Programmatic Routes: Use <code>app.add_route(Routes(...))</code> or <code>router.add_route(Routes(...))</code>.</li> <li>Path Parameters: Capture dynamic values from the URL.</li> <li>Validators: Ensure path parameters meet specific criteria.</li> <li>Regex: Use regex for advanced path patterns.</li> <li>Routers: Organize routes into modular components.</li> </ul>"},{"location":"core-features/routing/#notes","title":"notes","text":"<p>In Nexio, you can add middleware specific to a router. This allows you to apply middleware to all routes within a router, making it easy to modularize and reuse middleware logic for specific parts of your application.</p>"},{"location":"core-features/session/","title":"Session Management in Nexios","text":"<p>Session management allows you to store and persist user-specific data across multiple requests. Nexios provides a robust session interface that enables secure and configurable session handling.</p> <p>Sessions are used to store temporary user data that persists across multiple HTTP requests. This is essential for user authentication, shopping carts, and maintaining stateful interactions in web applications.</p> <p>Nexios provides a <code>BaseSessionInterface</code> that allows developers to manage sessions efficiently. It includes functionality for setting, retrieving, and deleting session data, as well as handling expiration and cookie settings.</p>"},{"location":"core-features/session/#configuring-sessions-in-nexios","title":"Configuring Sessions in Nexios","text":"<p>Before using sessions, ensure your application is configured correctly. The session configuration is stored in the <code>session_config</code> attribute of the application\u2019s configuration.</p>"},{"location":"core-features/session/#example-configuration","title":"Example Configuration:","text":"<pre><code>from nexios.config import MakeConfig\n\nconfig = MakeConfig({\n    \"secret_key\",\"somthing-special\",\n    \"session\":{\n        \"session_cookie_name\" :  \"nexios_session\",\n        \"session_cookie_secure\" : True,  # Ensures HTTPS-only cookies\n        \"session_cookie_httponly\" : True,  # Prevents JavaScript access\n        \"session_expiration_time\" :1440 ,# Keeps the session persistent\n        \"session_permanent\" : False  # Keeps the session persistent,\n        \"session_refresh_each_request\" : False  # Refresh session on each request\n\n    }    \n})\n</code></pre>"},{"location":"core-features/session/#key-configuration-options","title":"Key Configuration Options:","text":"Option Description <code>session_cookie_name</code> Name of the session cookie <code>session_cookie_secure</code> Enforces HTTPS-only cookies <code>session_cookie_httponly</code> Prevents JavaScript access <code>session_expiration_time</code> Expiration time in minutes <code>session_permanent</code> Keeps session active even after closing the browser <code>session_refresh_each_request</code> Refresh session expiry on every request"},{"location":"core-features/session/#using-sessions-in-nexios","title":"Using Sessions in Nexios","text":"<p>Setting and Retrieving Session Data</p> <pre><code># ... \n@app.get(\"/endpoint\")\nasync def manage_session(request, session):\n    # Setting a session value   \n    request.session.set_session(\"username\", \"Dunamis\")\n\n    # Retrieving a session value\n    username = request.session.get_session(\"username\")\n    print(username)  # Output: Dunamis\n</code></pre> <p>Checking if a Session Exists <pre><code>if request.session.get_session(\"username\"):\n    print(\"Session exists\")\nelse:\n    print(\"Session does not exist\")\n</code></pre></p> <p>Deleting a Session Value <pre><code>session.delete_session(\"username\")\n</code></pre></p> <p>Retrieving All Session Data <pre><code>all_sessions = request.session.get_all()\nprint(dict(all_sessions))  # Convert items to dictionary\n</code></pre></p> <p>Session Expiration Handling</p> <p>Nexios automatically manages session expiration based on the configured settings.</p> <p>Checking if a Session Has Expired <pre><code>if request.session.has_expired():\n    print(\"Session has expired. Please log in again.\")\n</code></pre></p> <p>Getting Session Expiration Time <pre><code>expiration_time = request.session.get_expiration_time()\nprint(expiration_time)  # Outputs the expiration datetime\n</code></pre></p>"},{"location":"core-features/session/#session-storage-backends","title":"Session Storage Backends","text":"<p>By default, Nexios stores sessions in files or signed cookies:</p> <pre><code>MakeConfig({\n    \"session_manager\":\"cookies\" #or file\n})\n</code></pre> <p>but you can implement different storage mechanisms such as</p> <ul> <li>Database-backed sessions (MySQL, PostgreSQL)</li> <li>Redis-based session storage</li> </ul>"},{"location":"core-features/session/#example-using-redis-for-session-storage","title":"Example: Using Redis for Session Storage","text":"<pre><code>from nexios.session.base import BaseSessionInterface\nfrom redis import Redis\n\nclass RedisSession(BaseSessionInterface):\n    def __init__(self, session_key: str):\n        super().__init__(session_key)\n        self.redis_client = Redis(host='localhost', port=6379, db=0)\n\n    async def save(self):\n        self.redis_client.set(self.session_key, self._session_cache)\n\n    async def load(self, key: str):\n        return self.redis_client.get(self.session_key)\n\n\nconfig = MakeConfig({\n    \"session\":{\n        \"backend\" : RedisSession()\n    }\n})\n</code></pre>"},{"location":"core-features/session/#session-security-best-practices","title":"Session Security Best Practices","text":"<ul> <li>Use Secure Cookies: Set <code>session_cookie_secure = True</code> to prevent transmission over HTTP.</li> <li>Enable HttpOnly: Prevents JavaScript from accessing session cookies.</li> <li>Set Expiration: Enforce <code>session_expiration_time</code> to prevent indefinite sessions.</li> <li>Rotate Session Keys: Periodically change session keys to prevent hijacking.</li> <li>Use Encrypted Storage: Encrypt session data when using databases or file storage.</li> </ul>"},{"location":"core-features/session/#advanced-session-use-cases","title":"Advanced Session Use Cases","text":"Use Case Implementation Persistent Logins Store user authentication state in session Shopping Carts Keep track of items in a cart across requests Role-Based Access Control Store user roles and permissions in session API Rate Limiting Track user requests to prevent abuse CSRF Protection Use session tokens to validate form submissions"},{"location":"core-features/validator/","title":"Validation in Nexios","text":"<p>The Validation module in Nexios is a powerful, extensible, and developer-friendly library built on top of Marshmallow. It provides a declarative way to define schemas, validate incoming data, and serialize responses. With its intuitive API and seamless integration with Nexios, it simplifies data validation and transformation in modern ASGI applications.</p>"},{"location":"core-features/validator/#getting-started","title":"Getting Started","text":""},{"location":"core-features/validator/#basic-usage","title":"Basic Usage","text":"<p>Here\u2019s a simple example of how to use the Nexios Validator module in a Nexios application: <pre><code>from nexios import get_application\nfrom nexios.validator import Schema, fields, validate,ValidationError\napp = get_application()\n\nclass UserSchema(Schema):\n    id = fields.Int(dump_only=True)\n    name = fields.Str(required=True)\n    email = fields.Email(required=True)\n\n@app.post(\"/users\")\nasync def create_user(request, response):\n    data = await request.json\n    schema = UserSchema()\n\n    try:\n        schema.load(data)\n    except ValidationError as err:\n        return reponse.json(err.messages,status_code = 422)\n    return response.json(data)\n</code></pre></p>"},{"location":"core-features/validator/#core-concepts","title":"Core Concepts","text":""},{"location":"core-features/validator/#schema-definition","title":"Schema Definition","text":"<p>Schemas are the core of the Nexios Validator module. They define the structure of your data and the rules for validation and serialization.</p>"},{"location":"core-features/validator/#example-schema","title":"Example Schema","text":"<pre><code>from nexios.validator import Schema, fields\n\nclass ProductSchema(Schema):\n    id = fields.Int(dump_only=True)\n    name = fields.Str(required=True)\n    price = fields.Float(required=True)\n    in_stock = fields.Bool(default=True)\n</code></pre>"},{"location":"core-features/validator/#validation","title":"Validation","text":"<p>Validation ensures that incoming data conforms to the schema. The <code>@validate_request</code> decorator from <code>.utils.validator</code> automatically validates request data and passes the validated data to your route handler.</p>"},{"location":"core-features/validator/#example-validation","title":"Example Validation","text":"<pre><code>@app.post(\"/products\")\n@validate_request(schema)\nasync def create_product(request, response):\n    data = request.validated_data\n    return response.json(data)\n</code></pre>"},{"location":"core-features/validator/#serialization","title":"Serialization","text":"<p>Serialization converts complex data types (e.g., objects) into JSON-compatible formats. Use the <code>dump</code> method to serialize data.</p>"},{"location":"core-features/validator/#example-serialization","title":"Example Serialization","text":"<pre><code>@app.get(\"/products\")\nasync def get_products(request, response):\n    products = [\n        {\"id\": 1, \"name\": \"Laptop\", \"price\": 999.99, \"in_stock\": True},\n        {\"id\": 2, \"name\": \"Mouse\", \"price\": 19.99, \"in_stock\": False},\n    ]\n    schema = ProductSchema(many=True)\n    return response.json(schema.dump(products))\n</code></pre>"},{"location":"core-features/validator/#error-handling","title":"Error Handling","text":"<p>The nexios.validator module provides detailed error messages for invalid data. Use the <code>ValidationError</code> exception to handle errors.</p>"},{"location":"core-features/validator/#example-error-handling","title":"Example Error Handling","text":"<pre><code>from nexios.validator import ValidationError\n\n@app.post(\"/products\")\n@validate(schema=ProductSchema)\nasync def create_product(request, response, data):\n    try:\n        # Process validated data\n        return response.json(data)\n    except ValidationError as err:\n        return response.json({\"error\": err.messages}, status=400)\n</code></pre>"},{"location":"core-features/validator/#advanced-features","title":"Advanced Features","text":""},{"location":"core-features/validator/#nested-schemas","title":"Nested Schemas","text":"<p>Nested schemas allow you to validate and serialize complex, hierarchical data structures.</p>"},{"location":"core-features/validator/#example-nested-schema","title":"Example Nested Schema","text":"<pre><code>class AddressSchema(Schema):\n    street = fields.Str(required=True)\n    city = fields.Str(required=True)\n    zipcode = fields.Str(required=True)\n\nclass UserSchema(Schema):\n    id = fields.Int(dump_only=True)\n    name = fields.Str(required=True)\n    address = fields.Nested(AddressSchema)\n</code></pre>"},{"location":"core-features/validator/#custom-validators","title":"Custom Validators","text":"<p>Custom validators enable you to define application-specific validation logic.</p>"},{"location":"core-features/validator/#example-custom-validator","title":"Example Custom Validator","text":"<pre><code>from nexios.validator import validates, ValidationError\n\nclass UserSchema(Schema):\n    name = fields.Str(required=True)\n\n    @validates(\"name\")\n    def validate_name(self, value):\n        if len(value) &lt; 3:\n            raise ValidationError(\"Name must be at least 3 characters long.\")\n</code></pre>"},{"location":"core-features/validator/#api-reference","title":"API Reference","text":""},{"location":"core-features/validator/#schema","title":"<code>Schema</code>","text":"<ul> <li><code>dump(obj)</code>: Serialize an object.</li> <li><code>load(data)</code>: Deserialize and validate data.</li> <li><code>validate(data)</code>: Validate data without deserialization.</li> </ul>"},{"location":"core-features/validator/#fields","title":"<code>fields</code>","text":"<ul> <li><code>Str</code>: String field.</li> <li><code>Int</code>: Integer field.</li> <li><code>Float</code>: Float field.</li> <li><code>Bool</code>: Boolean field.</li> <li><code>Email</code>: Email field.</li> <li><code>Nested</code>: Nested schema field.</li> </ul>"},{"location":"core-features/validator/#decorators","title":"Decorators","text":"<ul> <li><code>@validate(schema)</code>: Validate request data using the specified schema.</li> </ul>"},{"location":"core-features/validator/#examples","title":"Examples","text":""},{"location":"core-features/validator/#example-1-user-registration","title":"Example 1: User Registration","text":"<pre><code>class UserSchema(Schema):\n    id = fields.Int(dump_only=True)\n    name = fields.Str(required=True)\n    email = fields.Email(required=True)\n    password = fields.Str(required=True, load_only=True)\n\n@app.post(\"/register\")\n@validate(schema=UserSchema)\nasync def register(request, response):\n    # Save user to database\n    data = request.validated_data\n    return response.json({\"message\": \"User registered successfully\"})\n</code></pre>"},{"location":"core-features/validator/#example-2-product-catalog","title":"Example 2: Product Catalog","text":"<pre><code>class ProductSchema(Schema):\n    id = fields.Int(dump_only=True)\n    name = fields.Str(required=True)\n    price = fields.Float(required=True)\n\n@app.get(\"/products\")\nasync def get_products(request, response):\n    products = [\n        {\"id\": 1, \"name\": \"Laptop\", \"price\": 999.99},\n        {\"id\": 2, \"name\": \"Mouse\", \"price\": 19.99},\n    ]\n    schema = ProductSchema(many=True)\n    return response.json(schema.dump(products))\n</code></pre>"},{"location":"core-features/validator/#best-practices","title":"Best Practices","text":"<ol> <li>Use Schemas Consistently: Define schemas for all data models.</li> <li>Leverage Custom Validators: Add application-specific validation logic.</li> <li>Handle Errors Gracefully: Provide meaningful error messages for invalid data.</li> <li>Optimize Performance: Use async validation for I/O-bound tasks.</li> </ol>"},{"location":"core-features/validator/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Use caching for frequently accessed data.</li> <li>Batch process large datasets to reduce overhead.</li> <li>Avoid unnecessary validation in high-traffic routes.</li> </ul> <p>This documentation provides a comprehensive guide to using the Nexios Validator module. The <code>nexios.validator</code> module is a fork of the Marshmallow validator, designed to provide enhanced request validation within the Nexios framework. It extends Marshmallow's functionality to better integrate with Nexios, supporting streamlined data validation for JSON, form data, and URL-encoded requests.  </p> <p>For more details, refer to the official: - Nexios documentation - Marshmallow documentation</p>"},{"location":"core-features/websocket/","title":"WebSocket Support","text":"<p>WebSockets allow for full-duplex communication between a client and a server over a single, long-lived connection. This makes them ideal for real-time applications like chat apps, live notifications, and gaming.</p> <p>Nexios provides built-in support for WebSockets through its <code>WebSocket</code> class and the <code>@app.websocket_route</code> decorator. These tools make it easy to create WebSocket endpoints and handle real-time communication.</p>"},{"location":"core-features/websocket/#basic-websocket-endpoint","title":"Basic WebSocket Endpoint","text":"<p>A basic WebSocket endpoint in Nexios can be created using the <code>@app.websocket_route</code> decorator. Here\u2019s an example:</p> <pre><code>from nexios.websockets import WebSocket, WebSocketDisconnect\n# ...\n\n@app.websocket_route(\"/ws\") #or router.ws_route\nasync def websocket_endpoint(websocket: WebSocket):\n    # Accept the WebSocket connection\n    await websocket.accept()\n    try:\n        while True:\n            # Receive a message from the client\n            data = await websocket.receive_text()\n            # Send a response back to the client\n            await websocket.send_text(f\"Message text was: {data}\")\n    except WebSocketDisconnect:\n        # Handle client disconnection\n        print(\"Client disconnected\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"core-features/websocket/#explanation","title":"Explanation:","text":"<ul> <li><code>@app.websocket_route(\"/ws\")</code>: This decorator defines a WebSocket route at the path <code>/ws</code>.</li> <li><code>websocket.accept()</code>: Accepts the WebSocket connection. This is required to establish the connection.</li> <li><code>websocket.receive_text()</code>: Waits for a text message from the client.</li> <li><code>websocket.send_text()</code>: Sends a text message back to the client.</li> <li><code>WebSocketDisconnect</code>: An exception that is raised when the client disconnects. You can use this to clean up resources or log the disconnection.</li> </ul>"},{"location":"core-features/websocket/#class-based-websocket-controller","title":"Class-Based WebSocket Controller","text":"<p>For more complex applications, you can use class-based controllers to encapsulate WebSocket logic. This approach improves code organization and reusability.</p> <p>Here\u2019s an example of a class-based WebSocket controller:</p> <pre><code>from nexios.websockets import WebSocket\nfrom nexios.websocket.consumer import WebSocketEndpoint\nfrom nexios.routing import WebsocketRoutes\n#.....\nclass WebSocketController:\n\n\n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Accept the WebSocket connection.\"\"\"\n        await websocket.accept()\n        print(\"WebSocket connection accepted.\")\n\n    async def on_receive(self, websocket: WebSocket):\n        \"\"\"Handle incoming WebSocket messages.\"\"\"\n        try:\n            while True:\n                # Receive a message from the client\n                data = await websocket.receive_text()\n                print(f\"Received message: {data}\")\n                # Send a response back to the client\n                await self.send_text(f\"Echo: {data}\")\n        except WebSocketDisconnect:\n            # Handle client disconnection\n            print(\"Client disconnected.\")\n\napp.add_ws_route(WebSocketController())\n</code></pre>"},{"location":"core-features/websocket/#explanation_1","title":"Explanation:","text":"<ul> <li><code>WebSocketController</code>: A class that encapsulates WebSocket logic.</li> <li><code>aawait websocket.accept()</code>: Accepts the WebSocket connection.</li> <li><code>on_receive</code>: Handles incoming messages </li> <li><code>send_text</code>: Sends a message back to the client.</li> </ul>"},{"location":"core-features/websocket/#handling-json-data","title":"Handling JSON Data","text":"<p>WebSockets often exchange JSON data for structured communication. Here\u2019s how you can handle JSON messages in Nexios:</p> <pre><code>from nexios.websockets import WebSocket, WebSocketDisconnect\n\n#...\n\n@app.websocket_route(\"/ws/json\")\nasync def websocket_json_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_json()\n            await websocket.send_json({\"response\": \"JSON received\"})\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")\n</code></pre> <ul> <li><code>receive_json</code>: Parses incoming JSON data into a Python dictionary.</li> <li><code>send_json</code>: Converts a Python dictionary into a JSON string.</li> </ul>"},{"location":"core-features/websocket/#broadcasting-messages","title":"Broadcasting Messages","text":"<p>To broadcast messages to all connected clients, you can maintain a list of active WebSocket connections:</p> <pre><code>from nexios.websockets import WebSocket, WebSocketDisconnect\n\nactive_connections = []\n\n@app.websocket_route(\"/ws/broadcast\")\nasync def websocket_broadcast_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    # Add the connection to the list of active connections\n    active_connections.append(websocket)\n    try:\n        while True:\n            # Receive a message from the client\n            data = await websocket.receive_text()\n            # Broadcast the message to all active connections\n            for connection in active_connections:\n                await connection.send_text(f\"Broadcast: {data}\")\n    except WebSocketDisconnect:\n        # Remove the connection from the list of active connections\n        active_connections.remove(websocket)\n        print(\"Client disconnected\")\n</code></pre> <ul> <li><code>active_connections</code>: A list to store all active WebSocket connections.</li> <li>Broadcasting: Iterates over all connections and sends the same message.</li> </ul>"},{"location":"core-features/websocket/#error-handling","title":"Error Handling","text":"<p>Handle errors gracefully in WebSocket endpoints:</p> <pre><code>from nexios.websockets import WebSocket, WebSocketDisconnect\n\napp = Nexios()\n\n@app.websocket_route(\"/ws/error\")\nasync def websocket_error_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            if data == \"error\":\n                # Simulate an error\n                raise ValueError(\"Simulated error\")\n            await websocket.send_text(f\"Message: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")\n    except Exception as e:\n        # Handle other exceptions\n        print(f\"Error: {e}\")\n        await websocket.send_text(f\"Error: {str(e)}\")\n</code></pre>"},{"location":"core-features/websocket/#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>You can implement authentication by validating tokens or credentials during the WebSocket handshake:</p> <pre><code>from nexios.websockets import WebSocket, WebSocketDisconnect\n\napp = Nexios()\n\n@app.websocket_route(\"/ws/secure\")\nasync def websocket_secure_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    # Get the token from the query parameters\n    token = websocket.query_params.get(\"token\")\n    if token != \"secret-token\":\n        # Close the connection if the token is invalid\n        await websocket.close(code=1008, reason=\"Unauthorized\")\n        return\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Secure message: {data}\")\n    except WebSocketDisconnect:\n        print(\"Client disconnected\")\n</code></pre>"},{"location":"core-features/websocket/#websocket-router-and-middleware-in-nexios","title":"WebSocket Router and Middleware in Nexios","text":""},{"location":"core-features/websocket/#websocket-router","title":"WebSocket Router","text":"<p>In Nexios, the <code>WebsocketRoutes</code> class helps manage multiple WebSocket endpoints efficiently. Instead of defining WebSocket routes directly on <code>app</code>, you can organize them using <code>WebsocketRoutes</code> and mount them to the app.</p>"},{"location":"core-features/websocket/#example-using-websocket-router","title":"Example: Using WebSocket Router","text":"<pre><code>from nexios.websockets import WebSocket, WebSocketDisconnect\nfrom nexios.routing import WSRouter\n\nws_router = WSRouter()\n\n@ws_router.ws_route(\"/chat\")\nasync def chat_websocket(websocket: WebSocket):\n    \"\"\"Handles WebSocket connections for chat.\"\"\"\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Chat Message: {data}\")\n    except WebSocketDisconnect:\n        print(\"Chat client disconnected\")\n\n@ws_router.ws_route(\"/notifications\")\nasync def notifications_websocket(websocket: WebSocket):\n    \"\"\"Handles WebSocket connections for notifications.\"\"\"\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Notification received: {data}\")\n    except WebSocketDisconnect:\n        print(\"Notification client disconnected\")\n\n# Mount the WebSocket router to the main app\napp.mount_ws_router(ws_router)\n</code></pre>"},{"location":"core-features/websocket/#benefits-of-using-wsrouter","title":"Benefits of Using <code>WSRouter</code>","text":"<ul> <li>Organized Structure: Groups multiple WebSocket endpoints together.</li> <li>Reusability: Can be reused across different parts of the app.</li> <li>Easy Integration: Mounted to the main app using <code>app.include_ws_router()</code>.</li> </ul>"},{"location":"core-features/websocket/#websocket-middleware","title":"WebSocket Middleware","text":"<p>Middleware in Nexios allows you to modify WebSocket requests before they reach the route handler. This is useful for authentication, logging, or custom processing.</p>"},{"location":"core-features/websocket/#example-websocket-authentication-middleware","title":"Example: WebSocket Authentication Middleware","text":"<pre><code>from nexios.websockets import WebSocket\n\nasync def auth_check(websocket: WebSocket, call_next):\n\"\"\"Middleware to check authentication token in WebSocket connections.\"\"\"\n    token = websocket.query_params.get(\"token\")\n    if token != \"valid-token\":\n        await websocket.close(code=1008, reason=\"Unauthorized\")\n        return\n    print(\"Client authenticated.\")\n   await call_next()\n\n# Apply middleware to WebSocket routes\napp.add_ws_middleware(auth_check)\n</code></pre>"},{"location":"core-features/websocket/#combining-routers-and-middleware","title":"Combining Routers and Middleware","text":"<p>You can combine routers and middleware for a structured WebSocket setup:</p> <pre><code>ws_router = WSRouter()\n\n@ws_router.ws_route(\"/secured-chat\")\nasync def secured_chat(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Secure Chat: {data}\")\n\napp.mount_ws_router(ws_router)\napp.add_ws_middleware(AuthMiddleware)  # Protect all WebSocket routes\n</code></pre>"},{"location":"core-features/websocket/#summary","title":"Summary","text":"Feature Purpose Example Use Case WebSocket Router (<code>WSRouter</code>) Groups multiple WebSocket endpoints Chat, Notifications, Broadcasting WebSocket Middleware (<code>WebSocketMiddleware</code>) Pre-processes WebSocket connections Authentication, Logging, Custom Headers <p>This setup ensures scalability, maintainability, and security in real-time applications. Let me know if you need more details! </p>"},{"location":"guides/nexio-request/","title":"Nexio Request object","text":"<p>The Nexios Request is an object that is provided by nexios in the handler arguments . </p>"},{"location":"guides/nexio-request/#route_params","title":".route_params","text":"<p><code>In Nexio, route parameters are dynamic placeholders in the URL path, enclosed in curly braces. They capture specific values from the URL and are passed as function arguments. These parameters allow you to define flexible, resource-based routes that can adapt to different inputs, such as IDs or other identifiers, making your API more versatile and dynamic.</code></p> <pre><code>@app.route(\"/posts/{post_id}\")\nasync def route_handler(request, response):\n\n    print(request.route_params.post_id) #return the pramater passed as `/post/90`\n    print(request.route_params.items()) #return a key value tuple in a list [(key,value),(key,value)]\n</code></pre>"},{"location":"guides/nexio-request/#cookies","title":".cookies","text":"<p><code>Cookies are small pieces of data stored by the browser on a user's device. They are sent between the server and client with each HTTP request, allowing the server to remember user preferences, authentication details, or session information. Cookies can be persistent (remaining for a specified duration) or session-based (deleted when the browser is closed). They are often used for things like keeping users logged in or tracking user behavior across sessions. in nexio thie attr is typically stores as dict and access as same .</code></p> <pre><code>@app.route(\"/user-session\")\nasync def route_handler(request, response):\n\n    print(request.cookies['key']) #return the Value for the key else raise KeyError`\n    print(request.cookies.items()) #return a key value tuple in a list [(key,value),(key,value)]\n</code></pre>"},{"location":"guides/nexio-request/#headers","title":".headers","text":"<p><code>Headers in HTTP are like the notes that come with a package when it's sent. They provide important details about the package (data), such as its type, how it should be handled, or any special instructions, like authentication info.</code></p> <p>For example:</p> <p><code>Content-Type</code> tells the server what kind of data the client is sending, like saying, \"I'm sending a JSON file.\"</p> <p><code>Authorization</code> might be like a key or password, letting the server know who the client is. User-Agent identifies which browser or app is making the request. Accept tells the server what type of response the client wants, like asking, \"Can you send me that in JSON format?\"</p> <p>Essentially, headers help ensure that the server and client understand each other and can properly exchange information.`</p> <pre><code>@app.route(\"/headers\")\nasync def route_handler(request, response):\n\n    print(request.headers['key']) #return the Value for the key else raise None`\n    print(request.headers.items()) #return a key value tuple in a list [(key,value),(key,value)]\n</code></pre>"},{"location":"guides/nexio-request/#content-type","title":".content-type","text":"<p>Content-Type is an HTTP header that specifies the format of the data being sent, helping the server or client know how to interpret it (e.g., JSON, HTML, or file uploads).</p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(request, response):\n\n  print(request.content_type) # Returns the MIME type of the request content.\n</code></pre>"},{"location":"guides/nexio-request/#client","title":".client","text":"<p>The <code>.client()</code> method returns a tuple with the client's host (IP address or hostname) and port (connection port). It's useful for logging, identifying request origins, or applying specific rules.</p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(request, response):\n\n  print(request.client()) #Returns client information as a tuple of (host, port).\n</code></pre>"},{"location":"guides/nexio-request/#query_params","title":".query_params","text":"<p><code>The .query_params method extracts query parameters from a URL and returns them as a dictionary.</code></p> <p>For example, if the URL is:</p> <p><code>/search?category=books&amp;category=electronics&amp;sort=price</code></p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(request, response):\n\n  print(request.query_params()) #The method would return: {'category': ['books', 'electronics'], 'sort': 'price'}\n</code></pre>"},{"location":"guides/nexio-request/#base_url","title":".base_url","text":"<p><code>the base URL refers to the root URL for the API, from which all endpoint paths are built. It's the starting point for constructing full URLs in your application.</code></p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(request, response):\n\n  print(request.base_url) \n</code></pre>"},{"location":"guides/nexio-request/#body","title":".body()","text":"<p><code>This property asynchronously retrieves the raw body content of the request. The body is typically the data sent by the client (e.g., form data, JSON). The body is retrieved in chunks, and the method ensures that all data is read before returning it.</code></p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(request, response):\n  body = await request.body()\n  print(request.query_params()) #The method would return: {'category': ['books', 'electronics'], 'sort': 'price'}\n</code></pre>"},{"location":"guides/nexio-request/#json","title":".json()","text":"<p><code>This property asynchronously parses the request body as JSON. It tries to decode the body into a Python dictionary. If the body is not valid JSON or cannot be decoded, it returns an empty dictionary. This is useful for APIs that expect JSON input.</code></p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(request, response):\n  body = await request.json()\n  print(request.query_params()) #The method would return: {'category': ['books', 'electronics'], 'sort': 'price'}\n</code></pre>"},{"location":"guides/nexio-request/#form_data","title":".form_data()","text":"<p><code>This property asynchronously parses the request body as form data. It handles both multipart/form-data (used for file uploads) and application/x-www-form-urlencoded (used for standard form submissions). The method ensures that both types are handled properly and returns the parsed form data as a dictionary.</code></p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(request, response):\n  body = await request.form_data()\n  return response.json({\"text\":\"success\"})\n</code></pre>"},{"location":"guides/nexio-request/#stream","title":".stream()","text":"<p><code>This method asynchronously yields chunks of the request body. It is useful for handling large requests that are too big to fit into memory at once. This method can be used to stream data from the client in smaller parts, which can be processed incrementally.</code></p> <pre><code>@app.route(\"/endpoint\")\nasync def route_handler(request, response):\n\n    # Start streaming the request body\n    chunked_data = []\n\n    async for chunk in await request.stream():\n        # Collecting chunks to simulate processing\n        chunked_data.append(chunk.decode())\n\n    # Join all the chunks and return a response\n    full_data = ''.join(chunked_data)\n    return response.send(\"Data recieve successfully\")\n</code></pre>"},{"location":"guides/nexio-response/","title":"Nexio Response","text":"<p><code>NexioResponse</code> is an object that represents the HTTP response sent from the server to the client in the Nexio framework. It allows for setting headers, cookies, status codes, and other response attributes.</p>"},{"location":"guides/nexio-response/#core-methods","title":"Core Methods","text":""},{"location":"guides/nexio-response/#statuscode","title":".status(code)","text":"<p>Sets the HTTP status code for the response.</p> <pre><code>@app.route(\"/status\")\nasync def route_handler(request, response):\n    return response.status(201)  # Created\n</code></pre> <p>Common status codes: - <code>200</code>: OK (default) - <code>201</code>: Created - <code>400</code>: Bad Request - <code>404</code>: Not Found - <code>500</code>: Internal Server Error</p>"},{"location":"guides/nexio-response/#sendcontent-status_code200","title":".send(content, status_code=200)","text":"<p>Sends a plain text response to the client.</p> <pre><code>@app.route(\"/text\")\nasync def route_handler(request, response):\n    return response.send(\"Hello world\", status_code=201)\n</code></pre>"},{"location":"guides/nexio-response/#jsondata-status_code200","title":".json(data, status_code=200)","text":"<p>Sends a JSON response with automatic serialization.</p> <pre><code>@app.route(\"/json\")\nasync def route_handler(request, response):\n    return response.json({\n        \"status\": \"OK\",\n        \"data\": {\"user\": \"John\"}\n    })\n</code></pre>"},{"location":"guides/nexio-response/#htmlcontent-status_code200","title":".html(content, status_code=200)","text":"<p>Sends an HTML response with proper content-type headers.</p> <pre><code>@app.route(\"/html\")\nasync def route_handler(request, response):\n    return response.html(\"&lt;h1&gt;Welcome&lt;/h1&gt;\")\n</code></pre>"},{"location":"guides/nexio-response/#headerkey-value","title":".header(key, value)","text":"<p>Sets a custom HTTP header.</p> <pre><code>@app.route(\"/headers\")\nasync def route_handler(request, response):\n    return response.header(\"X-Custom\", \"value\").send(\"Custom Header Added\")\n</code></pre>"},{"location":"guides/nexio-response/#file-handling","title":"File Handling","text":""},{"location":"guides/nexio-response/#filepath-filenamenone-content_disposition_typeattachment","title":".file(path, filename=None, content_disposition_type=\"attachment\")","text":"<p>Streams a file as response with optional custom filename.</p> <pre><code>@app.route(\"/download\")\nasync def route_handler(request, response):\n    return response.file(\n        path=\"files/document.pdf\",\n        filename=\"report.pdf\"\n    )\n</code></pre>"},{"location":"guides/nexio-response/#streamiterator-content_typetextplain","title":".stream(iterator, content_type=\"text/plain\")","text":"<p>Creates a streaming response for large data sets.</p> <pre><code>@app.route(\"/stream\")\nasync def route_handler(request, response):\n    def generate():\n        for i in range(100):\n            yield f\"data chunk {i}\\n\"\n\n    return response.stream(generate())\n</code></pre>"},{"location":"guides/nexio-response/#cookie-management","title":"Cookie Management","text":""},{"location":"guides/nexio-response/#set_cookiekey-value-options","title":".set_cookie(key, value, **options)","text":"<p>Sets a cookie with various optional parameters.</p> <pre><code>@app.route(\"/cookies\")\nasync def route_handler(request, response):\n    return response.set_cookie(\n        \"session\", \n        \"abc123\",\n        max_age=3600,\n        httponly=True,\n        secure=True,\n        samesite=\"Strict\"\n    )\n    return response.send(\"Cookie Set\")\n</code></pre> <p>Cookie options: - <code>max_age</code>: Lifetime in seconds - <code>expires</code>: Explicit expiration date - <code>path</code>: Cookie path (default: \"/\") - <code>domain</code>: Cookie domain - <code>secure</code>: HTTPS-only flag - <code>httponly</code>: JavaScript access prevention - <code>samesite</code>: Cross-site request handling</p>"},{"location":"guides/nexio-response/#delete_cookiekey-options","title":".delete_cookie(key, **options)","text":"<p>Removes a cookie by setting its expiration to the past.</p> <pre><code>@app.route(\"/remove-cookie\")\nasync def route_handler(request, response):\n    response.delete_cookie(\"session\")\n    return response.send(\"Cookie Removed\")\n</code></pre>"},{"location":"guides/nexio-response/#caching-control","title":"Caching Control","text":""},{"location":"guides/nexio-response/#cachemax_age3600-privatetrue","title":".cache(max_age=3600, private=True)","text":"<p>Enables response caching with specified options.</p> <pre><code>@app.route(\"/cached\")\nasync def route_handler(request, response):\n    response.cache(\n        max_age=60,  # 60 seconds\n        private=True\n    )\n    response.json({\"data\": \"cached\"})\n</code></pre> <p>Cache properties: - <code>max_age</code>: Cache duration in seconds - <code>private</code>: Client-only caching - <code>public</code>: Shared caching allowed</p>"},{"location":"guides/nexio-response/#no_cache","title":".no_cache()","text":"<p>Disables caching for the response.</p> <pre><code>@app.route(\"/no-cache\")\nasync def route_handler(request, response):\n    response.no_cache()\n    return response.send(\"Not cached\")\n</code></pre>"},{"location":"guides/nexio-response/#redirection","title":"Redirection","text":""},{"location":"guides/nexio-response/#redirecturl-status_code302","title":".redirect(url, status_code=302)","text":"<p>Performs an HTTP redirect to the specified URL.</p> <pre><code>@app.route(\"/redirect\")\nasync def route_handler(request, response):\n    return response.redirect(\"/new-location\")\n</code></pre>"},{"location":"guides/nexio-response/#error-handling","title":"Error Handling","text":"<p>When sending error responses, it's recommended to include appropriate status codes and messages:</p> <pre><code>@app.route(\"/error\")\nasync def route_handler(request, response):\n    return response.json({\n        \"error\": \"Bad Request\",\n        \"message\": \"Invalid parameters\"\n    },status_code = 400)\n</code></pre>"},{"location":"guides/nexio-response/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Use streaming responses for large files or data sets</li> <li>Enable caching for static or rarely-changing content</li> <li>Set appropriate content-type headers</li> <li>Use compression when possible</li> <li>Include ETags for cache validation</li> </ol>"},{"location":"guides/nexio-response/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Always set appropriate security headers</li> <li>Use secure cookie options for sensitive data</li> <li>Validate and sanitize response content</li> <li>Implement proper CORS headers when needed</li> <li>Use HTTPS-only cookies for sensitive data</li> </ol> <p>This comprehensive set of features allows you to create secure, efficient, and flexible web applications while maintaining clean and maintainable code through the fluent interface design.</p>"},{"location":"guides/routing/","title":"Routing And handlers","text":""},{"location":"guides/routing/#what-is-routing","title":"What is routing ?","text":"<p>Routing in Nexios  works similarly to expressjs but slightly diffrent . In this case, define routes using decorators like @app.route() where the route and the HTTP methods are specified as arguments. For example, @app.route(\"/api/endpoint\", methods=['get']) sets up a handler for GET requests at the specified endpoint.</p>"},{"location":"guides/routing/#what-is-a-handler","title":"What is a handler  ?","text":"<p>A handler in nexios an async function or a class with a __call__ Method which will be executed when the corresponding route is match it typically require only two argument (request, response)</p> <p>example</p> <pre><code>from nexios.cbc import APIHandler\nfrom nexios.routers import Routes\n\nasync def function_handler(request, response):\n    return response.send(\"Hello, this is a function type handler\")\n\nclass class_handler(APIHandler):\n\n    def get(self, request, response):\n        return response.send(\"Hello, this a class type handler\")\n\napp.add_route(Routes(function_handler))\napp.add_route(Routes(class_handler())) #Note the class based handler is instantiated\n</code></pre> <p>When a request matches this route, the corresponding asynchronous handler function (like endpoint_handler()) is called, which takes the request and response objects as arguments. Inside the function, the response is generated and sent back to the client using methods like response.send(). This allows the application to respond with the desired content, in this case, \"Hello world\".</p> <p>Although Nexios Provide multiple option for route handling, Here are some examples of route paths based on strings. This route path will match requests to the root route, /.</p> <p>Query strings are not part of the route path.</p> <p><pre><code>@app.route(\"/endpoint\",methods = ['get'])\nasync def endpoint_handler(request, response):\n    return response.json({\"text\":\"hello world\"})\n</code></pre> This route path will match requests to /endpoint and {\"text\":\"hello world\"} will be returned as a response . the request will only support GET method <p>The above example is the equivalent as thise example</p> <pre><code>from nexios.routers import Routes\nasync def endpoint_handler(request, response):\n    return response.json({\"text\":\"hello world\"})\n\napp.add_route(Routes(\"/endpoint\",endpoint_handler,methods = ['get']))\n</code></pre> <p> If the methods arguent is not passed the route will support all methods . </p> <p>Here are some examples of route paths based on strings.</p> <p>This route path will match requests to /about.</p> <pre><code>from nexios.routers import Routes\n\nasync def about_handler(request,response):\n    return response.send(\"About Endpoint\")\n\napp.add_route(Routes(\"/about\",about_handler))\n</code></pre> <p>This route path will match requests to /random.text.</p> <pre><code>from nexios.routers import Routes\n\nasync def random_handler(request,response):\n    ...\n\napp.add_route(Routes(\"/random.txt\",about_handler))\n</code></pre> <p>Here are some examples of route paths based on string patterns.</p> <p>This route path will match acd and abcd.</p> <pre><code>from nexios.routers import Routes\n\nasync def handler(request,response):\n    ...\n\napp.add_route(Routes(\"/ab?cd\",handler))\n</code></pre> <p>This route path will match abcd, abbcd, abbbcd, and so on.</p> <p><pre><code>async def handler(request,response):\n    ...\n\napp.add_route(Routes(\"/ab+cd\",handler))\n</code></pre> This route path will match abcd, abxcd, abRANDOMcd, ab123cd, and so on.</p> <pre><code>async def handler(request,response):\n    ...\n\napp.add_route(Routes(\"/ab*cd\",handler))\n</code></pre> <p>This route path will match <code>/abe</code> and <code>/abcde</code>.</p> <pre><code>from nexios.routers import Routes\n\nasync def handler(request, response):\n    return response.send(\"Matched route: /ab(cd)?e\")\n\napp.add_route(Routes(\"/ab(cd)?e\", handler))\n</code></pre>"},{"location":"guides/routing/#matching-paths-ending-with-specific-text","title":"Matching Paths Ending with Specific Text","text":"<p>This route path will match <code>butterfly</code> and <code>dragonfly</code>, but not <code>butterflyman</code> or <code>dragonflyman</code>.</p> <pre><code>from nexios.routers import Routes\n\nasync def handler(request, response):\n    return response.send(\"Matched route: ends with 'fly'\")\n\napp.add_route(Routes(\"/.*fly$\", handler))\n</code></pre> <p><code>Regular expression routes provide powerful matching capabilities and are ideal for dynamic or complex patterns.</code></p>"},{"location":"guides/routing/#dynamic-route-parameters","title":"Dynamic Route parameters","text":"<p>Dynamic Route parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values are populated in the request.route_params object, with the name of the route parameter specified in the path as their respective keys.</p> <p>To define routes with route parameters, simply specify the route parameters in the path of the route as shown below.</p> <pre><code>from nexios.routers import Routes\n\nasync def handler(request, response):\n    print(request.route_params) #print out the value of /posts/anything\n    return response.send(\"Route with dynamic parameter\")\n\napp.add_route(Routes(\"/posts/{id}\", handler))\n</code></pre> <p>Route parameter names must consist only of \"word characters\" ([A-Za-z0-9_]).</p> <p>Since the hyphen (-) and the dot (.) are interpreted literally, they can be used along with route parameters for useful purposes.</p> <pre><code>Route path: /flights/{from}-{to}\nRequest URL: http://localhost:3000/flights/LAX-SFO\nreq.params: { \"from\": \"LAX\", \"to\": \"SFO\" }\n</code></pre> <p><pre><code>Route path: /plantae/{genus}.{species}\nRequest URL: http://localhost:3000/plantae/Prunus.persica\nreq.params: { \"genus\": \"Prunus\", \"species\": \"persica\" }\n</code></pre> <code>To have more control over the exact string that can be matched by a route parameter, you can append a regular expression in parentheses (()):</code></p> <pre><code>Route path: /user/{userId}(\\d+)\nRequest URL: http://localhost:3000/user/42\nreq.params: {\"userId\": \"42\"}\n</code></pre> <p>Response Methods The methods on the response object in the table below can send a response to the client and end the request-response cycle. If none of these methods are invoked in a route handler, the client request will remain unresolved.</p> Method Description Parameters Returns Use Case <code>send()</code> Sends the response as an HTTP response. <code>scope</code>, <code>receive</code>, <code>send</code> None (sends the response to the client) Used in asynchronous Django applications (ASGI) to send responses back to the client. It\u2019s the core method for sending responses in async Django views. <code>json()</code> Sends a JSON response, commonly used in APIs. <code>data</code> - Python object to be converted to JSON  <code>status_code</code> - HTTP status code (optional)  <code>headers</code> - Additional response headers (optional) A <code>JsonResponse</code> object (subclass of <code>Response</code>) Typically used for API responses where data needs to be sent in JSON format. Converts Python objects (like dictionaries) into JSON. <code>status()</code> Sets the HTTP status code for the response. <code>status_code</code> - The HTTP status code to be set (e.g., 200, 404, 500) The <code>Response</code> object with updated status code Useful when you need to modify the status code of a response based on different scenarios (e.g., error handling). <code>file()</code> Sends a file as the HTTP response, supporting file streaming. <code>path</code> - Path to the file  <code>filename</code> - Suggested filename for download (optional)  <code>content_disposition_type</code> - 'inline' or 'attachment'  <code>headers</code> - Additional response headers (optional) A <code>FileResponse</code> object (subclass of <code>Response</code>) Ideal for serving downloadable files (e.g., PDFs, images, or documents). Can be used for large file downloads as it supports streaming. <code>html()</code> Sends an HTML response to be rendered by the browser. <code>content</code> - The HTML content to be rendered  <code>status_code</code> - Optional HTTP status code  <code>headers</code> - Additional headers for the response (optional) An <code>HTMLResponse</code> object (subclass of <code>Response</code>) Useful for returning dynamically generated HTML content from Django views. This can be rendered directly by browsers as an HTML document. <code>set_cookie()</code> Sets a cookie in the response header. <code>key</code> - Name of the cookie  <code>value</code> - Value to store in the cookie  <code>max_age</code> - Expiry time in seconds  <code>expires</code> - Expiry date  <code>path</code>, <code>domain</code>, <code>secure</code>, <code>httponly</code>, <code>samesite</code> - Other optional cookie attributes None (modifies response headers) Used to store cookies in the user's browser. Cookies can store session information or any user-specific data (e.g., language preference, authentication tokens). <code>delete_cookie()</code> Deletes a cookie by setting an expired date in the past. <code>key</code> - Name of the cookie to delete  <code>path</code>, <code>domain</code> - Optional, specify where the cookie was set None (modifies response headers) Useful for logging users out or removing stored data from the user's browser by deleting cookies."}]}